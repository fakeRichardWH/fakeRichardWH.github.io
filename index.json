[{"categories":["pandas"],"content":"步骤: ","date":"2022-02-21","objectID":"/post/ml%E5%AE%9E%E6%88%9801/:0:0","tags":["pandas","Python"],"title":"ML实战-特征工程-Two sigma租房数据","uri":"/post/ml%E5%AE%9E%E6%88%9801/"},{"categories":["pandas"],"content":"1.获取数据 在terminal中输入: wget https://cdn.coggle.club/kaggle/two-sigma-connect-rental-listing-inquiries.zip unzip two-sigma-connect-rental-listing-inquiries.zip ","date":"2022-02-21","objectID":"/post/ml%E5%AE%9E%E6%88%9801/:1:0","tags":["pandas","Python"],"title":"ML实战-特征工程-Two sigma租房数据","uri":"/post/ml%E5%AE%9E%E6%88%9801/"},{"categories":["pandas"],"content":"2.读取数据 import pandas as pd import numpy as np test_df = pd.read_json(\"train.json.zip\", compression = \"zip\") test_df = pd.read_json(\"test.json.zip\", compression = \"zip\") ","date":"2022-02-21","objectID":"/post/ml%E5%AE%9E%E6%88%9801/:2:0","tags":["pandas","Python"],"title":"ML实战-特征工程-Two sigma租房数据","uri":"/post/ml%E5%AE%9E%E6%88%9801/"},{"categories":["pandas"],"content":"3.特征工程 ","date":"2022-02-21","objectID":"/post/ml%E5%AE%9E%E6%88%9801/:3:0","tags":["pandas","Python"],"title":"ML实战-特征工程-Two sigma租房数据","uri":"/post/ml%E5%AE%9E%E6%88%9801/"},{"categories":["pandas"],"content":"数据统计 【特征提取步骤1.】 1、【统计训练集、测试集中所有房间个数，bedrooms与bathroom之和】，新增一列特征命名为num_rooms train_df[\"num_rooms\"] = train_df[\"bedrooms\"] + train_df[\"bathrooms\"] test_df[\"num_rooms\"] = test_df[\"bedrooms\"] + test_df[\"bathrooms\"] 2、【统计训练集、测试集中所有照片的数量】，新增一列特征命名为num_photos train_df[\"num_photos\"] = train_df[\"photos\"].apply(len) test_df[\"num_photos\"] = test_df[\"photos\"].apply(len) Pandas.Series.apply(func)是pandas中提供对Series中的值产生相应func作用的一个函数,上面的例子就是传入了一个len函数,对photos这个Series中的每个value也就是list元素进行求长度的运算,你也可以自定义一个func代替len计算 一个使用apply的例子🌰 \u003e\u003e s = pd.Series([20, 21, 12], index=['London', 'New York', 'Helsinki']) \u003e\u003e s Out[1]: London 20 New York 21 Helsinki 12 dtype: int64 # 使用匿名函数 对Series中的每个元素进行平方 # lambda x 中的x就是Series中的每个变量 \u003e\u003e s.apply(lambda x : x**2) Out[2]: London 400 New York 441 Helsinki 144 dtype: int64 3、【删除照片这一列】 train_df = train_df.drop('photos', axis=1) test_df = test_df.drop('photos', axis=1) Pandas.DataFrame.drop()方法默认是对每一行进行操作,如果要对列操作需要将axis设置为1 4、【对于具有文本特征的列进行分析】,统计训练集、测试集中description不重复单词个数，并删除原始description列 # 这里先是用匿名函数 对 description列的每个元素,用正则表达式带有空格的部分做了拆分 # 其次再用set方法保留不重复的单词,并进行个数统计len train_df[\"num_description_words_Distinct\"] = train_df[\"description\"].apply(lambda x : len(set(x.split(\" \")))) test_df[\"num_description_words_Distinct\"] = test_df[\"description\"].apply(lambda x : len(set(x.split(\" \")))) train_df.drop('description',axis = 1) test_df.drop('description',axis = 1) 5、【对于时间/日期元素处理】将时间元素的字符串列转为datetime object train_df[\"created\"] = pd.to_datetime(train_df[\"created\"]) test_df[\"created\"] = pd.to_datetime(test_df[\"created\"]) # 获取年/月/日/小时 train_df[\"created_hr\"] = train_df[\"created\"].dt.hour train_df[\"created_d\"] = train_df[\"created\"].dt.day train_df[\"created_m\"] = train_df[\"created\"].dt.month train_df[\"created_y\"] = train_df[\"created\"].dt.year test_df[\"created_hr\"] = test_df[\"created\"].dt.hour test_df[\"created_d\"] = test_df[\"created\"].dt.day test_df[\"created_m\"] = test_df[\"created\"].dt.month test_df[\"created_y\"] = test_df[\"created\"].dt.year 4、【count_encoder】 ","date":"2022-02-21","objectID":"/post/ml%E5%AE%9E%E6%88%9801/:3:1","tags":["pandas","Python"],"title":"ML实战-特征工程-Two sigma租房数据","uri":"/post/ml%E5%AE%9E%E6%88%9801/"},{"categories":["Python"],"content":"with关键字 with语句用于异常处理,相当于是对try...excepty...finally进行了封装,缩短了Python代码,简化了文件流资源的管理 ","date":"2022-02-13","objectID":"/post/python03/:0:0","tags":["with"],"title":"Python中with使用及远离","uri":"/post/python03/"},{"categories":["Python"],"content":"一个有问题的代码案例 file = open(\"./test.txt\",\"w\") file.write(\"hello world!\") file.close() 如果代码调用write()的过程中,出现异常,则close()将无法执行,从而导致该test.txt会被程序持续占用无法释放. ","date":"2022-02-13","objectID":"/post/python03/:1:0","tags":["with"],"title":"Python中with使用及远离","uri":"/post/python03/"},{"categories":["Python"],"content":"改进 file = open('./test_runoob.txt','w') try: file.write('hello world!') except OSError as err: print(\"OS error raised!\") finally: file.close() 这段代码的finally无论是否会发生资源的占用都会将对应的文件流资源关闭,不会因为执行了异常而占用资源. ","date":"2022-02-13","objectID":"/post/python03/:2:0","tags":["with"],"title":"Python中with使用及远离","uri":"/post/python03/"},{"categories":["Python"],"content":"使用with with open(\"./test.txt\",\"w\") as f: f.write(\"hello world!\") # 上面这个代码等效于try...except...finally # 验证资源是否关闭 f.closed Out[1]: True ","date":"2022-02-13","objectID":"/post/python03/:3:0","tags":["with"],"title":"Python中with使用及远离","uri":"/post/python03/"},{"categories":["Python"],"content":"使用with with open(\"./test.txt\",\"w\") as f: f.read() ","date":"2022-02-13","objectID":"/post/python03/:4:0","tags":["with"],"title":"Python中with使用及远离","uri":"/post/python03/"},{"categories":["pandas"],"content":"pandas数据结构 Pandas主要的两个数据结构是DataFrame 和 Series DataFrame: 二维数据结构,整个表格,多行多列 Series: 一维数据结构,可以看做是DataFrame的一个行或者一个列 如果从DataFrame查询出来的是一个区块,那么该区块仍然是DataFrame 而如果是个一维的数据,那么可以用Series的字典键值对进行快速访问 ","date":"2022-02-11","objectID":"/post/pandas03/:0:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"Series Series 类似一维数组,但是它仍然包含了数据和与之相关的数据索引 ","date":"2022-02-11","objectID":"/post/pandas03/:1:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"使用list创建Series import numpy as np import pandas as pd s1 = pd.Series([1, \"a\", 5.3, \"Test\"]) # 获取索引 s1.index # 获取数据 s1.values ","date":"2022-02-11","objectID":"/post/pandas03/:1:1","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"使用自定义的index创建Series import numpy as np import pandas as pd s2 = pd.Series([1, \"a\", 5.3, \"Test\"], index = [\"A\",\"B\",\"C\",\"D\"]) # 获取索引 s2.index # 获取数据 s2.values ","date":"2022-02-11","objectID":"/post/pandas03/:1:2","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"使用字典创建Series import numpy as np import pandas as pd dict1 = {\"Ohio\" : 300, \"Rivencrow\" : 400, \"Utah\" : 500} s3 = pd.Series(dict1) # 获取索引 s3.index # 获取数据 s3.values ","date":"2022-02-11","objectID":"/post/pandas03/:1:3","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"根据标签索引查询数据 类似Python中的dict # 查询s2 index = \"A\"的内容 s2[\"A\"] Out[1]: 1 # 查看数据类型 type(s2[\"A\"]) Out[2]: int # 获取多个值 在中括号中传入一个列表值 s2[[\"B\",\"A\"]] Out[3]: A 1 C 5.3 dtype: object # 查看返回类型 type(s2[[\"B\",\"A\"]]) Out[4]: pandas.core.series.Series DataFrame 每一列可以是不同的值类型 (数值,字符串,bool) 既有行索引index又有列索引columns ","date":"2022-02-11","objectID":"/post/pandas03/:2:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"创建方法 根据读取文件来创建 (txt, csv, excel, mySQL数据库) ","date":"2022-02-11","objectID":"/post/pandas03/:3:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"根据多个字典序列创建dataFrame data = { # 每个列名 + 列值 \"states\" : [\"Ohio\", \"Nevada\", \"Florida\",\"California\"], \"year\" : [2001,2000,2011,2002], \"Dash\" : [1.2, 1.3, 1.4, 1.5] } df = pd.DataFrame(data) Out[5]: states year Dash 0 Ohio 2001 1.2 1 Nevada 2000 1.3 2 Florida 2011 1.4 3 California 2002 1.5 # 查看所有index df.index Out[6]: RangeIndex(start=0, stop=4, step=1) #查看所有列名称 df.columns Out[7]: Index(['states', 'year', 'Dash'], dtype='object') #查看各个列的数据类型 df.dtypes Out[8]: states object year int64 Dash float64 dtype: object ","date":"2022-02-11","objectID":"/post/pandas03/:4:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"从DataFrame中查询 如果只查询的是一列或者一行,那么返回值是pd.Series 如果查询的是多列且多行,那么返回值是pd.DataFrame ","date":"2022-02-11","objectID":"/post/pandas03/:5:0","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"查询列 # 结果为Series type(df[\"year\"]) # 结果为DataFrame type(df[[\"year\",\"Dash\"]]) ","date":"2022-02-11","objectID":"/post/pandas03/:5:1","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"查询行 一般切片查询是不包含末尾的3,但是loc是包含的 返回的index是列名 df.loc[1] Out[9]: states Nevada year 2000 Dash 1.3 # 查询多行 df.loc[1:3] Out[10]: states year Dash 1 Nevada 2000 1.3 2 Florida 2011 1.4 3 California 2002 1.5 ","date":"2022-02-11","objectID":"/post/pandas03/:5:2","tags":["pandas","Python"],"title":"Pandas中DataFrame和Series总结","uri":"/post/pandas03/"},{"categories":["pandas"],"content":"pandas数据读取 Pandas读取表格类型的数据然后进行分析,支持的数据类型和读取方法如下 数据类型 格式 读取方法 csv, tsv, txt 用逗号分隔或者tab分隔的纯文本文件 pd.read_csv() excel 微软的xls/xlsx文件 pd.read_excel() mySQL 关系型数据库表 pd.read_sql() 读取纯文本文件 ","date":"2022-02-11","objectID":"/post/pandas02/:0:0","tags":["pandas","Python"],"title":"pandas数据读取","uri":"/post/pandas02/"},{"categories":["pandas"],"content":"1.1 读取csv,使用默认的标题行 一个DataFrame中,最左侧的是index,最上方的是columns(列名),中间的部分是data fpath = \"./ratings.csv\" ratings = pd.read_csv(fpath) # 查看数据的前10行 ratings.head(10) # 查看数据的形状 返回值为 (行数,列数) ratings.shape Out[2]: (100836,4) # 查看列名的列表 ratings.columns Out[3]: Index(['userID','movieID','rating','timestamp'], dtype = 'object') # 查看每一列的数据类型 ratings.dtypes Out[4]: 'userID': int64 'movieID': int64 'rating': float64 'timestamp': int64 dtype: object ","date":"2022-02-11","objectID":"/post/pandas02/:1:0","tags":["pandas","Python"],"title":"pandas数据读取","uri":"/post/pandas02/"},{"categories":["pandas"],"content":"1.2 读取txt文件,自定义分隔符和列名 fpath = \"./test.txt\" test = pd.read_csv( fpath, sep = '\\t' # 定义分隔符 使用正则表达式 header = None, # 没有标题行 所以设置为None names = ['birthDate', 'age', 'name'] # 定义列名 一定要和原数据一致 方便后续根据列名筛选数据 ) 读取excel文件 fpath = \"./test2.xlsx\" test2 = pd.read_excel(fpath) 读取MySQL数据库 import pymysql # 利用pymysql获取与数据库的连接 conn = pymsql.connect( host = \"127.0.0.1\", user = \"root\", password = \"123456\", database = \"db1\", charset = \"utf8\" ) # 传入两个参数: # 第一个参数是String类型的SQL语句 # 第二个参数是数据库的一个连接 db1 = pd.read_sql(\"select * from tableName1\", con = conn) db1 ","date":"2022-02-11","objectID":"/post/pandas02/:2:0","tags":["pandas","Python"],"title":"pandas数据读取","uri":"/post/pandas02/"},{"categories":["leetcode"],"content":"用递归及非递归方式实现二叉树的先/中/后序遍历 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:0:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"递归实现 递归过程,就是会访问同一个节点三次,而先序/中序/后序取决于打印的时机 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:1:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"节点数据结构 public class Node { //这是Node的结构 public int value; public Node left; public Node right; public Node(int value) { this.value = value; } } 可以看出:树本身就是递归定义的,二叉树的左子树也是同一个数据结构,右子树也是同一个数据结构 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:1:1","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"先序遍历 public void preOrderRecur(Node root) { // base case if (root == null) { return; } System.out.print(root.value + \" \"); preOrderRecur(root.left); preOrderRecur(root.right); } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:1:2","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"中序遍历 public void inOrderRecur(Node root) { // base case if (root == null) { return; } preOrderRecur(root.left); System.out.print(root.value + \" \"); preOrderRecur(root.right); } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:1:3","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"后序遍历 public void postOrderRecur(Node root) { // base case if (root == null) { return; } preOrderRecur(root.left); preOrderRecur(root.right); System.out.print(root.value + \" \"); } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:1:4","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"非递归实现 递归实现起来很简单,但是递归调用会耗费很多内存(栈空间),同时也更加耗时;递归调用无非就是将函数帧入栈和出栈的操作用一个普通的stack实现,只是需要将栈中保存的内容变为树节点 需要明确两件事: 什么情况下入栈 什么情况下出栈 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:2:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"递归的非递归实现 仔细观察递归调用的过程，我们会发现这样的规律： 不管三七二十一先把从根节点开始的所有左子树节点放入栈中 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并以右子树为新的根节点重复过程1直到栈空为止 那么我们就可以思考什么时候入栈/出栈了: 什么时候入栈? 1.1 最开始时,将根节点开始的所有左子树节点放入栈内. 1.2 如果栈顶元素有右子树,那么就对其右子树重复步骤1 什么时候出栈? 2.1 查看栈顶元素时,实际上可以将栈顶元素pop掉,是因为查看栈顶元素的同时我们能够确认:当前节点的左子树一定已经处理完毕了 2.2 因此对于栈顶元素而言,需要的仅仅是拿到其右子树信息,再拿到右子树后该节点可以完全放心的pop掉 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:2:1","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"关键 明确了各个节点压栈,打印,弹栈的时机! 用代码来表示: public void nonRecur(Node root) { if (root == null) { return; } Deque\u003cNode\u003e stack = new LinkedList\u003c\u003e(); // 不管三七二十一,现将所有左子树加入栈中 while (root != null) { stack.push(root); root = root.left; } Node top = stack.peek(); Node curRight = top.right; while (!stack.isEmpty()) { // 如果栈顶元素有右子树,将其右子树入栈,并将栈顶元素弹出 stack.pop(); // 对栈顶元素的右子树作相同处理 while (curRight != null) { stack.push(curRight); curRight = curRight.left; } } } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:3:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"先序的非递归实现 总体思路: 对于每棵树而言都是先输出根,再到左子树,再到右子树;而我们压栈的过程是希望将左子树作为整体压入的,弹出的时候会先弹出最左侧的节点,这样就不能达到需要的效果了,所以我们可以在根节点入栈前,对其打印;然后压入右子树,再压入左子树 所以我们的策略就是,当左子树的节点弹出后,不要将其根节点对应的右子树立刻弹出,而是将左子树的剩余节点迅速压入栈,从而保证栈中是左子树的整体被压栈了. 具体步骤如下: 对于每个节点而言,先压入自身,然后弹出时就打印 如果有右子节点,那么先压入右子节点 如果有左子节点,那么先压入左子节点 只要栈不为空,就进行弹出 public void preOrderNonRecur(Node root) { if (root == null) { return; } Deque\u003cNode\u003e stack = new LinkedList\u003c\u003e(); stack.push(root); while (!stack.isEmpty()) { Node cur = stack.pop(); System.out.print(cur.value + \" \"); if (cur.right != null) { stack.push(cur.right); } if (cur.left != null) { stack.push(cur.left); } } } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:3:1","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"先序非递归实现的总结 现将头节点加入栈中(保证栈不是空的) 循环的每次迭代中: 从栈中弹出一个当前节点cur 打印这个节点cur 或者 (处理当前cur节点,比如加入结果集list中) 如果cur节点有右子节点和左子节点的话,先压入右子节点再压入左子节点 重复这个循环直到栈为空 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:4:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"中序的非递归实现 总体思路: 使用栈来代替程序中的递归调用栈. 对于中序遍历中的任意一个节点:先访问其左孩子,而其左孩子节点可以视为根节点,于是我们将这个左孩子压栈(记录下来),然后继续访问其左孩子的左孩子节点,直到遇到左孩子节点为空的情况,这时候我们就可以将所有访问过的节点弹出栈并且打印. 之后对栈顶的节点去访问其右孩子,并且对其右孩子按照上面相同的逻辑进行处理; 那么对于任意一个非空节点N: 如果其左孩子不为空,则将该节点N入栈,然后用N来记录N节点的左孩子 (也就是将左孩子设置为当前的N),然后对当前节点N再进行相同的处理; 如果左孩子为空,则弹出栈顶元素并打印 (说明当前节点是最左的),并且将当前的N来记录栈顶节点的右孩子(也就是将右孩子设置为当前的N); 直到N为null且栈元素为空,遍历完成 (说明我们的循环条件是或) public void inOrderNonRecur(Node root) { // 使用一个栈 Deque\u003cNode\u003e stack = new LinkedList\u003c\u003e(); // 利用一个节点来记录当前访问的节点 Node cur = root; while (!stack.isEmpty() || cur != null) { // 持续压栈直到左孩子为空 while (cur != null) { stack.push(cur); cur = cur.left; } // cur一旦不是空的 cur = stack.pop(); // 打印这一栈顶元素 // 也可以是将结果 添加到结果list中 // System.out.print(cur.value + \" \"); cur = cur.right; } return; } 另一种写法:每次只处理当前这个节点,处理完就相应的弹栈打印 public void inOrderNonRecur(Node root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); // 使用一个栈 Deque\u003cNode\u003e stack = new LinkedList\u003c\u003e(); // 利用一个节点来记录当前访问的节点 Node cur = root; // 栈元素为空,且当前节点也为空说明完成了遍历 while (!stack.isEmpty() || cur != null) { if (cur != null) { stack.push(cur); cur = cur.left; } else { // cur == null 说明到了最左侧的左子节点 // 复用这个节点cur cur = stack.pop(); System.out.print(cur.value + \" \"); // 第二次循环会通过同一个父节点返回到右子节点 cur = cur.right; } } return res; } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:4:1","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"中序非递归实现总结 中序非递归的实现逻辑不同于前序和后序的非递归实现,就在于它对于根节点的打印时机处理不一样,而且要尽可能的找到最左的子树(左边界),并利用栈将最左的节点放在栈的最上方,之后选择弹出,返回了父节点,此时如果遇到有右子树时,再压入栈,重复上面的操作 压栈和打印的顺序就是: 压入头节点, 压入左节点(压栈到空为止,弹出并打印) 弹出父节点并打印 如果遇到右树,做相同的操作 ","date":"2022-01-27","objectID":"/post/leetcodeday08/:5:0","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"后序的非递归实现 总体思路: 后序遍历的输出就是:先左子树,后右子树,最后是根节点. 而先序的输出顺序则是:根,左,右;但是前面我们知道它的压栈的顺序是:根节点,右子节点,左子节点; 从而保证了对于每棵子树先输出根节点(由于压栈后立刻又弹出打印了),再到左子节点,最后输出右子节点的顺序 借助这个思路我们可以利用两个栈,一个栈用于压栈调整顺序,另一个栈收集最终的打印结果 方法1: 使用两个栈,由于第一个栈是按照中左右压入栈,然后弹出时就是左右中,利用第二个栈收集这个弹出结果 public void postOrderNonRecur(Node root) { Deque\u003cNode\u003e stack1 = new LinkedList\u003c\u003e(); Deque\u003cNode\u003e stack2 = new LinkedList\u003c\u003e(); if (root == null) { return; } //第一个栈用来调整顺序 stack1.push(root); while (!stack1.isEmpty()) { Node cur = stack1.pop(); // 栈1中将cur的左节点压入 if (cur.left != null) { stack1.push(cur.left); } // 栈1中将cur的右节点压入 if (cur.right != null) { stack1.push(cur.right); } stack2.push(cur); } //最后栈2中的元素就是所有的后序遍历结果 while (!stack2.isEmpty()) { System.out.print(stack2.pop().value + \" \"); } } 方法2: 直接用双端队列来保存这个栈中的结果,达到先入先出的目的,其实输出还是按照栈2的形式输出,只是能够将结果直接保存下来而已 public void postOrderNonRecur(Node root) { Deque\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); Deque\u003cNode\u003e stack = new LinkedList\u003c\u003e(); if (root == null) { return; } //第一个栈用来调整顺序 stack1.push(root); while (!stack.isEmpty()) { Node cur = stack.pop(); // 直接利用FIFO性质将所有结果向头部不断加入 queue.offerFirst(cur.val); // 栈中将cur的左节点压入 if (cur.left != null) { stack.push(cur.left); } // 栈中将cur的右节点压入 if (cur.right != null) { stack.push(cur.right); } } //最后将结果输出 while (!queue.isEmpty()) { System.out.println(queue.pollFirst().value + \" \"); } } ","date":"2022-01-27","objectID":"/post/leetcodeday08/:5:1","tags":null,"title":"Leetcode-二叉树的遍历","uri":"/post/leetcodeday08/"},{"categories":["leetcode"],"content":"广度优先搜索模版 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:0:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"核心思路 BFS核心思想就是把问题抽象为一个图，从一个节点开始，向四周扩散。一般来说，BFS都会使用到一个队列，这样就可以将一个节点周围的所有节点加入队列。 BFS相较于DFS（回溯算法）,但代价就是空间复杂度要比DFS高。 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:1:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"解决哪类子问题 由于这个图一般是有向无权图,也就是节点之间有方向的但是从任意两个相连的节点从A到B走过的步数一定是1.那么就有下面的推论: 从只有遍历完 所有 距离源点 source 的距离为 d 的所有结点以后，才能遍历到所有 距离源点 source 的距离为 d + 1 的所有结点。也可以使用「两点之间、线段最短」这条经验来辅助理解如下结论：从源点 source 到目标结点 target走直线走过的路径一定是最短的。 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:2:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"细节点注意 由于队列在循环过程中的size是在不断改变的,那么就需要将每轮循环由于poll改变之前的size记录下来 (也就是记录下来每轮需要从对列中取出的节点数量 == 当前一层的节点数量) 在任意子节点入队时,先要判断其是否为空 在任意节点出队时,要判断其相邻节点是否非空,才能加入队列 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:3:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"算法框架 问题的本质就是在一个图中，从起点start找到终点target的最短距离，BFS的本质就是干这个事情。这个问题的描述可以有各种变体： 走迷宫、岛屿数量。这类问题会添加限定条件比如某些位置不能走。 有两个单词，给出一些固定/非固定的替换，将其中一个变为另一个，每次能替换一个字符，最少要替换几次？ 连连看，点击两个坐标，如何判断两者中的最短连线有几个拐点？ // 计算起点 start 到终点 target 的最近距离 int bfs(Node start, Node target) { Deque\u003cNode\u003e q; //核心数据结构：队列 Set\u003cNode\u003e visited; // 避免重复访问 走回头路 // 将起点加入 初始队列 q.offer(start); visited.add(start); int step = 0; // 记录当前扩散到哪一步？ while (!q.isEmpty() ) { //队列不为空 int size = q.size(); //记录当前队列扩散了多少个节点 /* 将当前队列中的所有节点向四周扩散 */ // 当前层 加入 queue for（int i = 0; i \u003c size; i++) { Node cur = q.poll(); if (cur is target) { /* 判断是否是终点 */ return step;// 最短路径生成 } /* 当前节点的相邻节点加入队列中*/ for (Node x : cur.adjacent()) { q.offer(x); visited.add(x); } } //当前层遍历完 step++;//对最短路径长度更新 } // 队列为空，广度搜索结束 } 队列q就不说了，BFS的核心数据结构；cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。 至于为啥这样就一定是最短的路径呢，可以用反证法的思维，假设扩散到某一层的target位置已经是最短路径了，那么前面的层一定不包含target，否则就会终止扩散。 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:4:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"二叉树的最小高度 给定一个二叉树，找出其最小的深度，最小深度就是指从根节点到最近的叶子节点的节点数量。 叶子节点就是左右子节点都为null ","date":"2022-01-27","objectID":"/post/leetcodeday03/:5:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"思考的逻辑： 如何套用到BFS呢？ 明确起点 start 及终点 target 分别是什么，并且在什么条件下到达了终点 队列存储的是一系列待扩散的节点，利用for循环遍历队列中的节点，并且判断是否达到了目标节点 那在这里，起点就是root，终点就是叶节点，怎么判断是否到了叶节点？ if (cur.left == null \u0026\u0026 cur.right == null) int minHeight(TreeNode root) { Linkedlist\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); //HashSet\u003cTreeNode\u003e visited = new HashSet\u003c\u003e(); 不再是必要的了 因为二叉树不会重复访问 if (root == null) { return 0; } queue.offer(root); int minHeight = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u003c size; i++) { TreeNode cur = queue.poll(); if (cur.left == null \u0026\u0026 cur.right == null) { return minHeight; } // 否则就再将节点的左子树节点加入到队列中 if (cur.left != null) { queue.offer(cur.left); } if (cur.left != null) { queue.offer(cur.right); } } minHeight++; } } ","date":"2022-01-27","objectID":"/post/leetcodeday03/:5:1","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"岛屿数量 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。 一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设网格的四个边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 (总共有1个岛屿) 示例 2: 输入: 11000 11000 00100 00011 输出: 3 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:6:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"大体思路1: 深度优先遍历： 1.初始状态所有顶点都没被访问，从每一个顶点v出发，先访问该顶点v 2.依次从 v 的各个 未被访问visited[i][j] == false的临接顶点出发，以相同的逻辑遍历图，直到图中所有和v相通的顶点都被访问到 3.遍历完后，还有其他的点没有被访问到，则另选一个未被访问的顶点作为起始点 4.重复上述过程，直至所有点被访问 本题思路，上下左右相连为1的才被认为是连续岛屿 DFS方式： 设定目前指向一个岛屿中的某个点(i, j),寻找包含此点的边界 1.1 从 (i, j)向此点的上下左右 (i + 1, j)，(i - 1, j)，(i, j + 1)，(i, j - 1)做深度搜索 1.2 终止条件： 1.2.1 (i, j)越过了矩阵的边界 1.2.2 grid[i][j] == 0，代表此时分支已经越过了岛屿边界 1.3 搜索岛屿的同时,执行grid[i][j] = 0,代表该位置已经搜索过了 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:6:1","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"代码实现 package leetcode; import java.util.*; public class Main { static int[][] grid; public static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u003cString\u003e list = new ArrayList\u003c\u003e(); while(sc.hasNextLine()) { list.add(sc.nextLine()); } rows = list.size(); cols = list.get(0).length(); grid = new int[rows][cols]; for (int i = 0; i \u003c rows; i++) { for(int j = 0; j \u003c cols; j++) { grid[i][j] = list.get(i).charAt(j); } } System.out.println(Arrays.deeptoString(countIsland(grid))); } public int countIsland(int[][] grid) { int count = 0; int m = grid.length; int n = grid[0].length; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == 1) {//出现岛屿 dfs(grid, i, j); count++; } } } return count; } public void dfs(int[][] grid, int i, int j) { if (i \u003c 0 || j \u003c 0 || i \u003e= grid.length || j \u003e= grid[0].length || grid[i][j] == 0) return; grid[i][j] == 0; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } } ","date":"2022-01-27","objectID":"/post/leetcodeday03/:6:2","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday03/"},{"categories":["leetcode"],"content":"无向图中连通分量的数目 给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。 ","date":"2022-01-27","objectID":"/post/leetcodeday07/:1:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday07/"},{"categories":["leetcode"],"content":"创建Array of Lists的技巧 List\u003cInteger\u003e[] lists=new List[10]; //insertion for(int i = 0; i \u003c 10; i++){ lists[i]=new ArrayList\u003cInteger\u003e(); lists[i].add(i); lists[i].add(i+1); } //printing for(List\u003cInteger\u003e list:lists){ System.out.println(list.size()); } 可见这种创建方式: lists这个变量指向了一个数组,而数组的类型是List\u003cInteger\u003e,如果直接创建List\u003cList\u003cInteger\u003e\u003e才是最常见的创建方式 List\u003cList\u003cInteger\u003e\u003e lists = new ArrayList\u003c\u003e(); for (int i = 0;i \u003c 10; i++) { lists.add(new ArrayList\u003c\u003e()); } 但这种方式创建的Array of Lists无需提供实际的List的类型,事实上你甚至可以这样写: List[] lists=new List[10]; 因为从JVM的角度,给一个Object类型的List和Integer类型的List都需要相同的字节数,也就是说这个最终创建出来的数组大小空间会是一致的.唯一的区别(限制)在于这个Object类型的List的值没有限制,而Integer类型的List必须是Integer ","date":"2022-01-27","objectID":"/post/leetcodeday07/:1:1","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday07/"},{"categories":["leetcode"],"content":"输入实例 输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]] 0 3 | | 1 --- 2 4 输出: 2 import java.util.*; public class Solution { public int countComponents(int n, int[][] edges) { // 第 1 步：构建图 (邻接表) List\u003cInteger\u003e[] adj = new ArrayList[n]; for (int i = 0; i \u003c n; i++) { adj[i] = new ArrayList\u003c\u003e(); } // 无向图，所以需要添加双向引用 // 对于每个边的两个端点元素 相互添加 到各自的邻居表中 for (int[] edge : edges) { adj[edge[0]].add(edge[1]); adj[edge[1]].add(edge[0]); } // 第 2 步：开始广度优先遍历 int res = 0; // 构建一个 是否访问的数组 防止重复对该位置的邻居重复访问 boolean[] visited = new boolean[n]; // 对这n个点的邻居进行访问 for (int i = 0; i \u003c n; i++) { //如果某个节点已经访问过(在前面的某一轮由于连接,导致被记为访问过) if (!visited[i]) { bfs(adj, i, visited); res++; } } return res; } /** * @param adj 邻接表 * @param u 从 u 这个顶点开始广度优先遍历 * @param visited 全局使用的 visited 布尔数组 */ //bfs的逻辑是站在当前这个节点上,分辨出与其相连的节点,将这些点标记为已经访问过,后续不会再访问 private void bfs(List\u003cInteger\u003e[] adj, int u, boolean[] visited) { Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); queue.offer(u); visited[u] = true; while (!queue.isEmpty()) { Integer front = queue.poll(); // 获得队首结点的所有后继结点 List\u003cInteger\u003e successors = adj[front]; for (int successor : successors) { if (!visited[successor]) { queue.offer(successor); // 特别注意：在加入队列以后一定要将该结点标记为访问，否则会出现结果重复入队的情况 visited[successor] = true; } } } } 复杂度分析： 时间复杂度：$O(V + E)$，这里 $E$是边的条数，即数组 $edges$ 的长度，初始化的时候遍历数组得到邻接表。这里 V 为输入整数 $n$，遍历的过程是每一个结点执行一次深度优先遍历，时间复杂度为 $O(V)$； 空间复杂度：$O(V + E)$，综合考虑邻接表 $O(V+E)$、$visited$ 数组 $O(V)$、队列的长度 $O(V)$三者得到。 ","date":"2022-01-27","objectID":"/post/leetcodeday07/:2:0","tags":null,"title":"Leetcode-广度优先搜索模版","uri":"/post/leetcodeday07/"},{"categories":["machine learning"],"content":"XGBoost 由于它计算的准而且快，所以用在各大比赛当中使用的多，不要迷信深度学习 xGBoost = extreme + GBDT = extreme + Gradient + BoostDT Boosting -\u003e Boosting DT -\u003e gradient BDT -\u003e 使用了一阶梯度信息 ","date":"2022-01-26","objectID":"/post/ml02/:0:0","tags":["ML原理"],"title":"XGBOOST","uri":"/post/ml02/"},{"categories":["machine learning"],"content":"所谓的最优函数其实是由参数决定的，其实学习方式是用最优参数。构建了模型，然后对参数求偏导。但如果没有模型参数，只有f(x)，那我们也可以只对函数本身求偏导 ","date":"2022-01-26","objectID":"/post/ml02/:1:0","tags":["ML原理"],"title":"XGBOOST","uri":"/post/ml02/"},{"categories":["machine learning"],"content":"如何理解梯度提升算法？ 关键在于梯度提升算法使用的不再是基于参数的负梯度，而是基于模型的损失函数的负梯度作为下次迭代中残差的近似值 $\\argmin$ ","date":"2022-01-26","objectID":"/post/ml02/:2:0","tags":["ML原理"],"title":"XGBOOST","uri":"/post/ml02/"},{"categories":["machine learning"],"content":"朴素贝叶斯 目标: 解决的是多分类问题. 假设训练数据为$(X,Y)$,其中X为属性集合,Y为类别标记,这时候我们需要对新产生的样本x,进行类别预测,最终目标是求出最大概率:$P(y|x)$作为样本的分类. ","date":"2022-01-26","objectID":"/post/ml01/:0:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"边缘概率 (加法法则) $P(X) = \\sum_{Y}P(X,Y)$ 从直观上理解这个式子，要消除随机变量Y对联合概率的影响，那么就要固定(确定)每个Y的值，对联合概率求和，从而消除X的影响 ","date":"2022-01-26","objectID":"/post/ml01/:1:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"条件概率与联合概率的关系 (乘法法则) $P(X, Y) = P(Y|X)P(X) = P(Y|X)P(X)$ 条件概率$P(Y|X)$中由于X作为条件,已经被确定了那么就相当于减少（消除）了一部分的不确定性，而两个变量的联合概率分布的不确定性更大，所以需要补充的就是X本身的不确定性. ","date":"2022-01-26","objectID":"/post/ml01/:2:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"联合概率分布 $P(X,Y,Z) = P(X|Y,Z)P(X,Y|Z)P(Z)$ $P(X,Y,Z)$的联合概率分布，需要的是以X为变量，将Y，Z作为确定条件来降低不确定性，而补充这一不确定性需要当Z确定时的X，Y的不确定性和Z单独的不确定性 ","date":"2022-01-26","objectID":"/post/ml01/:3:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"朴素贝叶斯分类器 ","date":"2022-01-26","objectID":"/post/ml01/:3:1","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"引入条件独立性假设 $P(X, Y) = P(Y)P(X)$ 此时由于X，Y是相互独立的，所以X无论确定还是不确定，对Y的条件概率无影响，从而可以将朴素贝叶斯推出来 条件独立性假设：在标签一定(被确定)的基础上，X向量或者说特征向量，各个特征之间相互独立 推导: $P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)}, …,X^{(n)}=x^{(n)}| Y = c_{k}) = \\prod_{i}^{n}P(X^{(i)}=x^{(i)}|Y)$ 从而： $P(X=\\bf{x}|Y = c_{k}) = \\prod_{i}^{n}P(X^{(i)}=x^{(i)}|Y)$ 监督学习模型分类 ","date":"2022-01-26","objectID":"/post/ml01/:4:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"生成式模型 生成式模型,就是对每个类别分别建立一个模型,有多少个类别就建立多少个模型.学习的是条件概率分布:P(Y|X)=P(X|Y)P(Y)/P(X),一般常见的生成式模型就是朴素贝叶斯模型,因为需要对每个类别分别对特征集进行划分之后,再进行统计. 比如,一个信用评级模型中: 类别标签为{高, 中, 低},而属性集合包括了{房产数量,房产面积,年均收入},那么模型学习的就是三个不同的分布:$P(高|房产数量,房产面积,年均收入)$$P(中|房产数量,房产面积,年均收入)$$P(低|房产数量,房产面积,年均收入)$ 而当我们得到一个未知的样本X,将其输入到三个分布中,计算出使得某个类别概率最大的就是该样本对应的类别,比如: P(高|X) = 0.4,P(中|X)=0.5, P(低|X) = 0.1 那么我们可以认为这个样本X对应的信用评级类别就是中. ","date":"2022-01-26","objectID":"/post/ml01/:5:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"常见的生成式模型 HMM(隐马尔可夫模型),朴素贝叶斯模型,(GMM)高斯混合模型,LDA,马尔可夫随机场模型 ","date":"2022-01-26","objectID":"/post/ml01/:5:1","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"判别式模型 根据训练数据得到分类函数和划分界面,比如SVM模型就是得到多个分界面,然后直接计算条件概率.输入特征X,直接用一个模型将历史数据输入去学习拟合p(Y|X). ","date":"2022-01-26","objectID":"/post/ml01/:6:0","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"常见的判别式模型 ","date":"2022-01-26","objectID":"/post/ml01/:6:1","tags":["ML原理"],"title":"朴素贝叶斯及监督学习模型的分类","uri":"/post/ml01/"},{"categories":["pandas"],"content":"loc vs iloc loc函数：通过行索引 “Index” 中的具体值来取行数据（如取\"Index\"为\"A\"的行）可以认为是利用行名称来提取，方便记忆 而且当index具备特殊意思的时候： 例如 当index是人名时,会将所有相同人名字的信息提取出来 iloc函数：通过具体的行号来取行数据（如取第二行的数据）利用纯粹的下标索引找行数据，如果当对行名称不记得的时候可以使用 ","date":"2022-01-26","objectID":"/post/pandas01/:0:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"五种使用方法 本文给出loc、iloc常见的五种用法，并附上详细代码。 import numpy as np import pandas as pd # create a dataframe data = pd.DataFrame(np.arange(16).reshape(4, 4), index = list(\"abcd\"), columns = list(\"ABCD\")) In [6]: data Out[6]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 ","date":"2022-01-26","objectID":"/post/pandas01/:1:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"1. 取一整行数据 取出索引为“a”的行 data.loc[\"a\"] In [7]: data.loc[\"a\"] Out[7]: A 0 B 1 C 2 D 3 Name: a, dtype: int64 取出第一行数据(index == 0)，也就是索引为“a”的数据 In [8]: data.iloc[0] Out[8]: A 0 B 1 C 2 D 3 Name: a, dtype: int64 ","date":"2022-01-26","objectID":"/post/pandas01/:2:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"2. 取指定的行 和 列 数据 利用 loc 根据行和列的索引名称 获取 In [9]: data.loc[[\"a\",\"b\"],[\"A\",\"B\"]] Out[9]: A B a 0 1 b 4 5 在不知道数据分布情况下：使用行和列索引下标查询 In [10]: data.iloc[[0,1],[0,1]] Out[10]: A B a 0 1 b 4 5 ","date":"2022-01-26","objectID":"/post/pandas01/:3:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"3. 提取某一列的所有行数据 使用loc查询某一列所有行数据 In [11]: data.loc[:,[\"A\"]] Out[11]: A a 0 b 4 c 8 d 12 使用iloc查询某一列的所有信息 # 注意传入的参数都是 list In [12]: data.iloc[:,[0]] Out[12]: A a 0 b 4 c 8 d 12 ","date":"2022-01-26","objectID":"/post/pandas01/:4:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"4. 利用loc/iloc提取所有数据 In [13]: data.loc[:,:] Out[13]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 In [14]: data.iloc[:,:] Out[14]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 ","date":"2022-01-26","objectID":"/post/pandas01/:5:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["pandas"],"content":"5.利用loc函数，根据某个筛选条件来提取数据所在行 单个条件查询 In [15]: data.loc[data[\"A\"] == 0] # data[\"A\"]相当于拿出A一整列 Out[15]: A B C D a 0 1 2 3 # 获取相同的数据其他方法 # 使用dataframe访问方法 In [19]: data[data[\"A\"] == 0] Out[19]: A B C D a 0 1 2 3 # 使用df.isin([ value]) 方法 In [20]: data[data[\"A\"].isin([0])] Out[20]: A B C D a 0 1 2 3 多条件筛选 多个条件之间一定要加括号 否则会出错 In [17]: data.loc[(data[\"A\"] == 0) \u0026 (data[\"B\"] == 2)] Out[17]: Empty DataFrame Columns: [A, B, C, D] Index: [] # 使用isin()的查询方式 In [23]: data[(data[\"A\"].isin([0])) \u0026 (data[\"B\"].isin([2])) ] Out[23]: Empty DataFrame Columns: [A, B, C, D] Index: [] ","date":"2022-01-26","objectID":"/post/pandas01/:6:0","tags":["loc vs iloc","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["Python"],"content":"匿名函数 以lambda 作为关键字,可以在一行内完成定义和声明，这个匿名函数由于没有实际的名称，所以一般在Python中没有什么复杂的功能。 ","date":"2022-01-21","objectID":"/post/python02/:0:0","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"语法 lambda arg1, arg2, arg3 ... : \u003cexpression\u003e 其中 arg1,arg2,arg3是函数的输入参数，而\u003cexpression\u003e则是函数体，运算结果就是表达式结果。 ","date":"2022-01-21","objectID":"/post/python02/:1:0","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"例子 # 输入是x,y; 输出是x*y lambda x, y : x*y # 输入是空; 输出是None lambda : None # 输入是任意个数的参数（以tuple传入），但是隐含条件需要这些参数可以相加 lambda *args : sum(args) ","date":"2022-01-21","objectID":"/post/python02/:1:1","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"使用 lambda往往有下面三种常用的使用方式 ","date":"2022-01-21","objectID":"/post/python02/:2:0","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"赋值给其他变量 例如，执行语句 add = lambda x, y: x+y 定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。 ","date":"2022-01-21","objectID":"/post/python02/:2:1","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"替换其他函数 例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用： time.sleep = lambda x : None 。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行time.sleep(3)时，程序不会休眠3秒钟，而是什么都不做。 ","date":"2022-01-21","objectID":"/post/python02/:2:2","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"作为返回值 由于函数的返回值也可以是函数。例如 def cal(x, y): x = x**2 y = 1 return lambda x, y: x+y 返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。 ","date":"2022-01-21","objectID":"/post/python02/:2:3","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["Python"],"content":"内置函数接受lambda表达式 filter函数 filter(function, iterable)函数本身传入的第一个参数为函数名，第二参数为可迭代对象，返回值是可迭代对象 lambda用来作为指定过滤列表元素的条件。 import numpy as np list1 = np.arange(3) filter(lambda x : x % 2 == 0, list1) # result: [0,2] sorted函数 sorted(iterable, key = function)函数本身是对iterable对象中所有元素按照function排序 lambda用来作为指定的排序条件。 import numpy as np arr = np.arange(9) print(sorted(arr, key = lambda x : abs(5 - x))) # result: [5, 4, 6, 3, 7, 2, 8, 1, 0] # 结果是依次排序数组中离5最近的元素值 map函数 map(function, iterable)函数本身是对iterable对象中所有元素按照function排序 lambda用于指定对列表中每一个元素的相同映射操作。 import numpy as np list = np.arange(9) sqr = map(lambda x : x**2, list) print([x for x in sqr]) # result: [0, 1, 4, 9, 16, 25, 36, 49, 64] # 对[0,9]逐元素平方 ","date":"2022-01-21","objectID":"/post/python02/:2:4","tags":["匿名函数"],"title":"Lambda函数使用","uri":"/post/python02/"},{"categories":["leetcode"],"content":"题目 前提条件： 两个有序数组均为正序列，且两个数组有且仅有一个会是空数组 nums1.length = m,nums1.length = n 如果m+n == 2k,那么中位数为第k和k+1位置的数据的之和的一半 也就是$\\frac{m + n}{2}$ 和$\\frac{m + n}{2} + 1$ 如果m+n == 2k+1,那么中位数为k+1位置的数据 $\\frac{m + n}{2} + 1$ 分析 给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种： 注意： 当两个数组长度之和为偶数时，其中位数为总长度n的$\\frac{n - 2}{2}$位置上和$\\frac{n}{2}$位置上的取值之和的一半 当两个数组长度之和为偶数时，其中位数为总长度n的$\\frac{n}{2}$位置上的数值 思路1: 使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数 public double findMedianSortedArray(int[] nums1, int[] nums2) { int[] nums = new int[nums1.length + nums2.length]; int m = nums1.length; int n = nums2.length; //special case if (m == 0) { if (n % 2 == 0) {//长度为偶数 return (nums2[n / 2 - 1] + nums2[n / 2]) /2.0; } else { return (double) nums2[n / 2]; } } if (n == 0) { if (m % 2 == 0) {//长度为偶数 return (nums2[m / 2 - 1] + nums2[m / 2]) /2.0; } else { return (double) nums2[m / 2]; } } //合并两个有序数组 int count = 0; int i = 0, j = 0; while (count != (m + n)) {//这个逻辑不是唯一的 //可以改写 if (i == m) {//nums1 的指针已经到了边界 while (j != n) { nums[count++] = nums2[j++]; } } if (j == n) {//nums2 的指针已经到了边界 while (i != m) { nums[count++] = nums2[i++]; } } if (nums1[i] \u003c= nums2[j]) { nums[count++] = nums1[i++]; } else { nums[count++] = nums1[j++]; } } //返回合并后数组中位数 if (count % 2 == 0) {//长度为偶数 return (nums2[count / 2 - 1] + nums2[count / 2]) /2.0; } else { return (double) nums2[count / 2]; } } 思路2: 我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。 开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了for循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。 首先是怎么将奇数和偶数的情况合并一下。 用 len 表示合并后数组的长度: 如果是奇数，我们需要知道第 (len+1）/2 个数就可以了，如果遍历的话需要遍历 (int) (len/2) + 1 次。比如len长度为5,那么我们要拿到第三个数，需要遍历三次 如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。比如len长度为6,那么我们要拿到第三个和第四个数,可以遍历四次然后减1,拿到左边的数字 返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量pre和cur，cur保存当前循环的结果，在每次循环前将cur的值赋给pre。这样在进行最后一次循环的时候,pre将得到 cur的值，也就是上一次循环的结果，接下来cur更新为最后一次的结果。 循环中该怎么写，什么时候nums1数组后移，什么时候nums2数组后移。用p1和p2分别表示当前指向nums1数组和nums2数组的位置。如果p1还没有到最后并且此时nums1位置的数字小于nums2位置的数组，那么就可以后移了。也就是p1 ＜ m \u0026\u0026 nums1[p1]\u003c nums2[p2]。 但如果nums2数组此刻已经没有数字了，继续取数字nums2[p2]，则会越界，所以判断下p2是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 p1 ＜ m \u0026\u0026 (p2 \u003e= n || nums1[p1] \u003c nums2[p2]) 。其中p2 \u003e= n的优先级更高，因为即便这个条件为假也不妨碍后面的为真时的结果，但是这个如果为真，那就一定要移动p1指针了。 public double findMedianSortedArray(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int len = len1 + len2; int p1 = 0, p2 = 0;//设置两个数组指针 //设置记录值的容器 int cur = -1, pre = -1;//cur记录中位数 while (int i = 0; i \u003c len / 2; i++) {//循环 (len / 2) + 1 次 pre = cur; //每次遍历前 将上一轮的值赋给 pre if (p1 \u003c len1 \u0026\u0026 (p2 \u003e= len2 || nums1[p1] \u003c nums2[p2])) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } } //退出循环时 判断一下数组总长度 // 如果是偶数 if ((len \u0026 1) == 0) {//相当于进行了取余运算 return (pre + cur) / 2.0; } return (double) cur; } ","date":"2022-01-12","objectID":"/post/leetcodeday02/:0:0","tags":null,"title":"leetcode-找到两数组中的中位数","uri":"/post/leetcodeday02/"},{"categories":["leetcode"],"content":"两数之和 ","date":"2022-01-11","objectID":"/post/leetcodeday01/:0:0","tags":null,"title":"leetcode-两数之和twoSum","uri":"/post/leetcodeday01/"},{"categories":["leetcode"],"content":"思路1: 思路一: 对于nums数组中每个位置i上的x，要找到target-x,可以使用两层遍历，第一层遍历是遍历数组中的每个数字，第二层遍历是从该位置的后一个位置j = i + 1开始查看是否符合target - x 时间复杂度: $o(n^2)$ 空间复杂度: $o(1)$ public class Solution { public static void main(String[] args) { int[] nums = new int[]{1,3,2,4}; int target = 5; int[] result = find2Sum(nums, target); } public static int[] find2Sum(int[] nums, int target) { if (nums == null || nums.length \u003c= 1) { return null; } for (int i = 0; i \u003c nums.length; i++) { rest = target - nums[i]; for (int j = i + 1; j \u003c nums.length; j++) { if (nums[j] == rest) { return new int[]{i, j}; } } } return null; } } ","date":"2022-01-11","objectID":"/post/leetcodeday01/:1:0","tags":null,"title":"leetcode-两数之和twoSum","uri":"/post/leetcodeday01/"},{"categories":["leetcode"],"content":"思路2: 思路二:利用HashMap查询key只要o(1)时间的特性.我们将每个位置的数字nums[i]和其对应的索引i存入HashMap中，每次遍历过程遇到一个数字将(nums[i], i)键值对存储之前，先查询这个数字对应的target - nums[i]是否在HashMap中已经存储， 如果没有，那么就存入这个数字，遍历下一个数字 如果存在，说明当前数字和能找到对应的数字构成target 时间复杂度: $o(n)$ 空间复杂度: $o(n)$ ","date":"2022-01-11","objectID":"/post/leetcodeday01/:2:0","tags":null,"title":"leetcode-两数之和twoSum","uri":"/post/leetcodeday01/"},{"categories":["leetcode"],"content":"注意： HashMap创建时需要用到泛型 HashMap提供了 boolean containsKey(Integer key) 和 Integer get(Integer key)方法 import java.util.HashMap; public class Solution { public static void main(String[] args) { int[] nums = new int[]{1,3,2,4}; int target = 5; int[] result = find2Sum(nums, target); } public static int[] find2Sum(int[] nums, int target) { int[] result = new int[2]; HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{i, map.get(target - nums[i])}; } else { map.put(nums[i], i); } } return null; } ","date":"2022-01-11","objectID":"/post/leetcodeday01/:2:1","tags":null,"title":"leetcode-两数之和twoSum","uri":"/post/leetcodeday01/"},{"categories":null,"content":"VSCODE快捷键配置 [Mac] 下载好Markdown All in One这个插件后： 先输入Command + Shift + p : ，再找到默认键盘设置:(Open Default Keyboard Shortcut Settings JSON)，然后一一设置即可 ","date":"2021-12-22","objectID":"/post/shortcuts/:0:0","tags":["VSCODE"],"title":"Shortcuts VSCODE快捷键","uri":"/post/shortcuts/"},{"categories":null,"content":"自动切换为代码块 option(alt) + 0: 切换（添加）代码行 option(alt) + shift + 0:切换（添加）代码块 ","date":"2021-12-22","objectID":"/post/shortcuts/:1:0","tags":["VSCODE"],"title":"Shortcuts VSCODE快捷键","uri":"/post/shortcuts/"},{"categories":null,"content":"代码替换 option + Command + F:查找对应的变量名 并替换 ","date":"2021-12-22","objectID":"/post/shortcuts/:2:0","tags":["VSCODE"],"title":"Shortcuts VSCODE快捷键","uri":"/post/shortcuts/"},{"categories":null,"content":"mac fn + 触控屏 f2:使用f2键 ","date":"2021-12-22","objectID":"/post/shortcuts/:3:0","tags":["VSCODE"],"title":"Shortcuts VSCODE快捷键","uri":"/post/shortcuts/"},{"categories":["pytorch"],"content":"pytorch View视图 ","date":"2021-12-11","objectID":"/post/pytorch01/:0:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/pytorch01/"},{"categories":["pytorch"],"content":"你咋就这么特别呢？ 查看Pytorch官方文档: PyTorch allows a tensor to be a View(视图) of an existing tensor.View(视图) tensor shares the same underlying data with its base tensor. Supporting View(视图) avoids explicit data copy, thus allows us to do fast and memory efficient reshaping, slicing and element-wise operations. 也就是说 视图类型的tensor 本身 不是显式的拷贝了数据，而是使用了它的一个引用。 \u003e\u003e\u003e t = torch.rand(4, 4) \u003e\u003e\u003e b = t.view(2, 8) \u003e\u003e\u003e t.storage().data_ptr() == b.storage().data_ptr() # True 't' 和 'b' 用的是同一块内存 # 但是 b 的 shape 属性是改变了的 \u003e\u003e\u003e t.shape torch.Size([4, 4]) \u003e\u003e\u003e b.shape torch.Size([2, 8]) \u003e\u003e\u003e print(t) tensor([[0.4473, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(b) tensor([[0.4473, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) 由于共用一个地址空间，修改 b 也会同时修改 t \u003e\u003e\u003e b[0][0] = 1 \u003e\u003e\u003e print(b) tensor([[1.0000, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(t) tensor([[1.0000, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) ","date":"2021-12-11","objectID":"/post/pytorch01/:1:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/pytorch01/"},{"categories":["pytorch"],"content":"与view()类似的方法 Typically a PyTorch op returns a new tensor as output, e.g. add(). But in case of view ops, outputs are views of input tensors to avoid unncessary data copy. No data movement occurs when creating a view, view tensor just changes the way it interprets the same data. Taking a view of contiguous tensor could potentially produce a non-contiguous tensor. Users should be pay additional attention as contiguity might have implicit performance impact. transpose() is a common example. 可以看到一般来说一个Pytorch操作会返回一个新的tensor作为输出，也就是在一个新内存空间上申请了一个位置，例如add()方法，但是对于view的这种方式，一般输出都会避免不必要的数据深拷贝,仅仅是改变数据的读取顺序。 ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e c = torch.ones_like(b) \u003e\u003e\u003e print(c) tensor([[1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.]]) \u003e\u003e\u003e b = b.add(c) \u003e\u003e\u003e id(b) == id(c) False 需要注意的是：view()和reshape()最大的区别就是当你用view()查看一个连续的tensor的时候会产生不连续的tensor ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e d = torch.tensor([[1, 2],[3, 4]]) \u003e\u003e\u003e t = d.transpose(0,1) # `t`是d的一个view，没有发生地址变化 # 但是view tensor本身是不连续的 \u003e\u003e\u003e t.is_contiguous() False # 如果想要得到的 view tensor(视图张量)也是连续的 \u003e\u003e\u003e c = t.contiguous() 下面列举一些常见的方法也是类似View视图的操作，并且也具有刚才的几个坑 tensor[0, 2:, 1:7:2]返回的也是tensor的一个视图 unflatten() unfold() unsqueeze() squeeze() detach() 当通过索引来访问tensor，Pytorch和Numpy的机制类似，基础的索引就只是返回（views）视图（例如:通过索引赋值都是在原地址上修改），高级的索引操作返回的是数据的深拷贝。 ","date":"2021-12-11","objectID":"/post/pytorch01/:2:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/pytorch01/"},{"categories":["pytorch"],"content":"注意区分view() 和 reshape() reshape(), reshape_as() and flatten() 可以返回一个视图 或者 是一个新tensor contiguous() 返回它自身 当且仅当输入tensor已经是连续的了，否则就会返回一个新的拷贝后的连续tensor ","date":"2021-12-11","objectID":"/post/pytorch01/:3:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/pytorch01/"},{"categories":["Deep Learning"],"content":" 在图像复原的过程中，图像上一点点噪声就可能对复原的结果产生较大影响，由于复原算法本身一般都会放大噪声，这时候需要在最优化的问题模型中添加一个正则项约束图像的噪声 （其本身也是loss的一部分）比如图片中相邻像素值之间的差异，可通过降低TV loss来解决 ","date":"2021-12-07","objectID":"/post/dl02/:0:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/dl02/"},{"categories":["Deep Learning"],"content":"Total Variation Loss (TV loss)初始定义： Rudin等人(Rudin 1990)观察到，受到噪声污染的图像总变分大于无噪声的图像总变分。那么就可以通过最小化图像总变分去抑制噪声，而图片中相邻像素值的差异可以通过降低TV loss来一定程度上缓解。比如对抗checkerboard。 总变分定义为梯度幅值大小的积分 $$ J(u) = \\int_{\\Omega_{u}}|\\nabla_{u}|{dxdy} = \\int_{D_{u}}\\sqrt{u_{x}^{2}+v_{x}^{2}}dxdy $$ 其中： $$ u_{x} = \\frac{\\partial{u}}{\\partial{x}},v_{y} = \\frac{\\partial{v}}{\\partial{y}}, $$ 而图像支持域为 $ D_{u} $ ,限制总变分就会限制噪声 ","date":"2021-12-07","objectID":"/post/dl02/:1:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/dl02/"},{"categories":["Deep Learning"],"content":"扩展定义 带有阶数的TV loss如下 $$ J^{\\beta} (f)= \\int_{\\Omega}\\Big((\\frac{\\partial{f(u,v)}}{\\partial{u}})^{2}+(\\frac{\\partial{f(u,v)}}{\\partial{v}})^{2}\\Big)^{\\frac{\\beta}{2}}dxdy $$ 但是在图像中，连续的积分就是像素离散域求和 $$ J(x) = \\sum_{i,j}\\big( (x_{[i,j-1]}- x_{[i,j]})^{2}+(x_{[i+1,j]}- x_{[i,j]})^{2}\\big)^{\\frac{\\beta}{2}} $$ 也就是对于每个像素点$x_{[i,j]}$与其**正下方**的像素值差的平方加上其**正左方**的像素值差的平方，然后开$\\frac{\\beta}{2}$次根 ","date":"2021-12-07","objectID":"/post/dl02/:2:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/dl02/"},{"categories":["Deep Learning"],"content":"3.基于pytorch实现及效果分析 import torch import torch.nn as nn from torch.autograd import Variable class TVLoss(nn.Module): def __init__(self,TVLoss_weight = 1):#设置TVLoss_weight为1 super(TVLoss, self).__init__() self.TVLoss_weight = TVLoss_weight def forward(self, x): #输入tensor为x # x = [batchSize,width,height,channels] batch_size = x.size()[0] h_x = x.size()[2] w_x = x.size()[3] #计算图片高度 count_h = self._tensor_size(x[:,:,1:,:]) #计算图片宽度 count_w = self._tensor_size(x[:,:,:,1:]) h_tv = torch.pow(x[:,:,1:,:]-x[:,:,:h_x-1,:]，2).sum() w_tv = torch.pow((x[:,:,:,1:]-x[:,:,:,:w_x-1]),2).sum() return self.TVLoss_weight*2*( h_tv/count_h + w_tv/count_w) / batch_size def _tensor_size(self, t): return t.size()[1]*t.size()[2]*t.size()[3] def main(): # x = Variable(torch.FloatTensor([[[1,2],[2,3]],[[1,2],[2,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[3,1],[4,3]],[[3,1],[4,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[1,1,1], [2,2,2],[3,3,3]],[[1,1,1], [2,2,2],[3,3,3]]]).view(1, 2, 3, 3), requires_grad=True) x = Variable(torch.FloatTensor([[[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [2, 3, 4], [3, 4, 5]]]).view(1, 2, 3, 3),requires_grad=True) addition = TVLoss() z = addition(x) print x print z.data z.backward() print x.grad if __name__ == '__main__': main() ","date":"2021-12-07","objectID":"/post/dl02/:3:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/dl02/"},{"categories":["leetcode"],"content":" 题目描述：给定两个可能存在环或者不存在环的单链表head1和head2，找到两个链表的第一个相交节点。 总体思路： 我们希望有一个函数能调用后，告知我们一个链表是否有环，如果有环还能返回第一个入环节点。从而我们通过这个函数findLoopNode找到入环节点，接下来就可以分情况讨论两个链表相交的情况。 ","date":"2021-12-04","objectID":"/post/leetcodeday00/:0:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"1. 两链表都无环 即findLoopNode(head1) == findLoopNode(head2) = null。 1.1 如果两个链表相交的话:他们一定从某个节点开始有公共的部分并且公共部分会一直延伸到null节点。 1.2 否则二者一定不相交，从而我们可以通过两者到链表结尾的前一个非null节点判断是否相同判断是否相交。 若相交： 这时候让链表长度长的一方先走差值步数(len(head1) - len(head2)) 然后让链表长度短的与链表长度长的再次同时出发，如果相遇就是第一个相交🍌的节点 ","date":"2021-12-04","objectID":"/post/leetcodeday00/:1:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"2. 两链表中一个有环，一个无环 即findLoopNode(head1) == null || findLoopNode(head2) == null 2.1 这种情况下，无论如何两个链表一定不相交，读者可以在草稿纸上画着试一试，因为题目给定的是单链表，如果相交的话，就说明另一个链表也有环，从而和我们的假设相矛盾。 ","date":"2021-12-04","objectID":"/post/leetcodeday00/:2:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"3. 两链表都有环 即findLoopNode(head1) != null \u0026\u0026 findLoopNode(head2) != null 此时分为两种情况： ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"相交 Y字形开始相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ ^ | 6-\u003e3____| |__| 这种比较简单，只需要判断入环节点是否相等，如果相等，那么一定在某个位置开始有入环，比如🌰例子中的5节点，那么此时只需要类似将入环节点视为结尾点（或者当作null），按照两个无环链表相交的情况来寻找他们的相交点即可。 两链表相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9\u003c-3\u003c-6 ^ | |_____| 由于题目说要返回第一个相交节点，可以认为两个链表的其中一个入环节点就是相交节点，将其返回即可，此时要与不相交的情况分开就只有用 ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:1","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"不相交 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 3-\u003e0-\u003e6 ^ | |__| ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:2","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"主逻辑实现 public Node findIntersectNode(Node head1, Node head2) { if (head1 == null || head2 == null) { return null; } Node res1 = findLoopNode(head1); Node res2 = findLoopNode(head2); if (res1 == null \u0026\u0026 res2 == null) { //两链表都无环 return intersectPointYStyle(head1, head2, null); } else if (res1 == null || res2 == null) { //其中一个链表有环，另一个无环 return null; } else { if (res1 == res2) { return intersectPointYStyle(head1, head2, res1); } else {//剩下两个情况 1:都有环不相交 2:都有环但是是非Y型相交 res1 = res1.next; while (res1 != res1) { //让res1在环上绕圈 如果碰到 res2 //说明两者相交 if (res1 == res2) { return res1; } res1 = res1.next; } //绕圈中始终没碰到 res2 //说明二者不相交 return null; } } } //这个函数是找Y型相交链表的第一个相交点 public Node intersectPointYStyle(Node head1, Node head2, Node end) { Node cur1 = head1; Node cur2 = head2; int n = 0;//记录两链表的差值 while (cur1 != end) { n++; cur1 = cur1.next; } while (cur2 != end) { n--; cur2 = cur2.next; } //找到先出发的节点 Node first = n \u003e 0 ? head1 : head2; Node second = n \u003e 0 ? head2 : head1; n = Math.abs(n); //让长链表先走差值步 while (n \u003e 0) { first = first.next; n--; } //让两个链表同时走 while (first != second) { first = first.next; second = second.next; } return first; } ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:3","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"findLoopNode()实现： 如果一个单链表有环的话，那么从头节点出发，一定会在某个时刻走到原来的位置，反之就一定会走到null的位置。 因而可以使用快慢指针，如果slow或者fast指针走到了null节点，那么该链表一定不存在环。反之就会出现slow==fast的情况。 入环节点判断 设两指针fast，slow 指向链表头部 head，fast每轮走2步，slow每轮走1步；当fast == slow时，两指针在环中第一次相遇。 下面分析此时fast 与slow走过的步数关系： 设链表共有$a+b$个节点，其中链表头部到链表入口有$a$个节点（不计链表入口节点），链表环有b个节点。 这里需要注意: $a$和$b$是未知数，例如下面例子中链表 $a=4$, $b=2$。 例子: 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 相遇时: 设两指针分别走了 f ，s 步，则有：fast走的步数是slow步数的$2$倍，即 $f = 2s$ 相遇时:fast比slow多走了$n$个环的长度，即:$f = s + nb$;（解析: 双指针都走过 a步，然后在环内绕圈直到重合，重合时fast比 slow多走了环的长度整数倍； 以上两式相减得: $f = 2nb$,$s = nb$，即fast和slow指针分别走了 $2n$，$n$个环的周长（注意：$n$是未知数，不同链表的情况不同）。 目前情况分析： 如果让指针从链表头部一直向前走并统计步数$k$ ，那么所有走到链表入口节点时的步数是：$k = a + nb$ (即：先走$a$步到入口节点，之后每绕$1$圈环(走$b$步) 都会再次到入口节点) 而目前slow指针走过的步数为$nb$步。因此，我们只要想办法让 slow 再走 $a$步停下来，就可以到环的入口。 但是我们不知道$a$的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走$a$步后，两者在入口节点重合。 那么从哪里走到入口节点需要$a$步？答案是链表头部head。 双指针第二次相遇: slow指针位置不变 ，将 fast 指针重新指向链表头部节点;slow和 fast 同时每轮向前走1步； TIPS：此时 $f = 0$，$s = nb$； 当 fast 指针走到$f = a$步时,slow指针走到步$s = a+nb$，此时两指针重合，并同时指向链表环入口。 第二次相遇后，返回slow指针指向的节点即可。 ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:4","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["leetcode"],"content":"实现：（使用快慢指针） public findLoopNode(Node head) { if (head == null || head.next == null || head.next.next == null) { //由于我们希望快指针一开始就运动到比slow的下个位置 return null; } Node slow = head.next; Node fast = head.next.next; while (slow != fast) { if (fast.next == null || fast.next.next == null) {//一旦快指针走到终点，说明无环 return null; } slow = slow.next; fast = fast.next.next; } //相遇了,将fast指向slow fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } ","date":"2021-12-04","objectID":"/post/leetcodeday00/:3:5","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/leetcodeday00/"},{"categories":["Machine Learning"],"content":"推荐系统的实验方法分类 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:0:0","tags":null,"title":"推荐系统实验方法分类","uri":"/post/recommendationsystem01/"},{"categories":["Machine Learning"],"content":"1.离线实验 通过日志系统，获取用户行为数据，按照一定格式生产出一个标准的数据集 将数据集划分为训练集和测试集 在训练集上训练用户兴趣模型，并在测试集上进行预测 通过事先定义的离线指标评价算法在测试集上的预测结果 优点： 无需对实际系统有控制权（换言之，无需对真实有用户的系统来测试） 无需用户参与（仅仅根据用户历史数据） 速度快，可以测试大量算法 缺点： 无法真正计算商业上关注的指标：点击率，转化率（而且找到一个和商业指标相关的离线指标也很困难） 离线指标和实际商业指标有差距 （比如：预测准确率和用户的满意度之间就存在很大的差别） 总结 最好的办法就是将离线算法直接上线测试，但在对算法会不会降低用户满意度没有把握的情况下，上线测试有很高的风险，因此上线前一般需要进行一次用户调查 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:1:0","tags":null,"title":"推荐系统实验方法分类","uri":"/post/recommendationsystem01/"},{"categories":["Machine Learning"],"content":"2.用户调查 1.调查真实用户，让他们在真实的推荐系统上完成一些任务 2.观察和记录用户行为，并且让用户回答一些相关的问题 3.通过分析用户调查的行为和答案，了解测试系统性能 优点： 体现更多用户的主观感受指标，相对在线实验风险很低，出错后容易弥补 可以展现出真实的客户需求，及满意度 缺点： 招募测试用户代价很高，很难组织大规模的测试用户，使得测试结果的统计意义不足 设计双盲实验十分困难，用户在实验环境下的行为和真实场景会呈现出不同 总结： 需要选取与真实用户身份分布一致的测试用户数量，比如年龄/活跃度，此外需要保证用户的回答可靠，不要让实验者和用户提前知道测试的目的，以免回答受到影响 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:2:0","tags":null,"title":"推荐系统实验方法分类","uri":"/post/recommendationsystem01/"},{"categories":["Machine Learning"],"content":"3.在线实验 将推荐系统上线做AB测试，将它和旧的算法进行比较 优点： 缺点： 总结： ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:3:0","tags":null,"title":"推荐系统实验方法分类","uri":"/post/recommendationsystem01/"},{"categories":["Java Basics"],"content":"为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了 public static testStack() { Deque\u003cInteger\u003e stack = new Deque\u003cInteger\u003e(); stack.push(1); stack.push(3); stack.push(4); stack.peek(); // 4 stack.pop(); // 4 stack.pop(); // 3 stack.pop(); // 1 } Deque接口的stack主要调用有三个方法: push() peek() pop() 不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰 ","date":"2021-11-24","objectID":"/post/java01/:0:0","tags":["Java"],"title":"Stack在JAVA中的API","uri":"/post/java01/"},{"categories":null,"content":"Rage, rage against the dying of the light! Old days shall fade away. 致力于研究美食，发掘自身潜能的一枚 AI beginner. 撰写博客只是为了开心，更多的是记录自己的学习过程 更多关于我的介绍请看 Resume 个人简历 ","date":"2021-11-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Hugo"],"content":"GitHub设置 首先创建个人网站的一个repo： 注意命名规则:一定是你的用户名.github.io比如sophshep.github.io 详见下面这个图片: 建议：为了后续的开发也可以再创建一个仓库 Hugo安装及配置 首先安装 Hugo，在不同系统上安装都很简单，我使用的是 Mac ，使用 Homebrew 可以安装 Hugo： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:0","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"下载Hugo brew install hugo 创建一个基础网站 当你在当前路径下的终端内输入 hugo new site mySite 就会自动创建一个mySite的根文件夹┑(￣Д ￣)┍ ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:1","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"Hugo网站文件夹目录 顺带提一嘴这个文件结构，对后续写文章比较重要 mySite |–layout |–content |–static |–data |–themes |–config.toml |–archetypes content - 内容文件夹开发中的内容大多数都保存在这里 也就是markdown文件存储的位置 你post的文章的md后缀文件也会出现在这里 static - 静态文件夹一些静态的文件，比如说嵌入的图片,图片位置 themes - 主题文件夹 config.toml - 配置文件 基础的一些网站设置，比如网站的名字 archetypes - 样例文件夹 可以透过 hugo new \u003ccontentdir/contentfile.md\u003e来创建新的内容 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:2","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"选择并安装一个合适的主题并进行初始配置 挑选好一个theme之后load到你的本地 git submodule add \u003ctheme-github-url\u003e \u003ctarget-directory\u003e 下面我们要告诉Hugo我们所将使用的主题 echo 'theme = \"\u003ctheme-name\u003e\"' \u003e\u003e config.toml 我这里用的是： echo 'theme = \"even\"'\u003e\u003e config.toml 当然你也可以直接打开编辑器修改toml.config文件 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:1:0","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"本地测试一下你的新网站及博文 输入下面的命令后会自动发布一篇测试文章： hugo new post/testpage.md 新的testpage.md页面会存在content/post/testpage.md中，而content文件夹是Hugo创建静态网页的内容（你所写的博客基本都在这里） --- title: \"Testpage\" date: 2020-08-27T13:43:09-06:00 draft: true --- 打开archetypes/default.md可以发现，上面Testpage.md的内容是依赖下面的自动生成的，而draft的设置为true表明现在的Testpage处于草稿阶段，修改为false即可 --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true --- 需要注意的是： 第一个---到第二个--- 符号之间是front matter（Hugo的专用术语）类似于HTML中的\u003cmeta\u003e标签是用来定义页面头部的一些信息（渲染标题和其他的元数据）的，而在第二个--- 符号之后就是你的正文部分 或者说相当于HTML的body 关于config.toml的一些设置偏好 baseurl: 就是你想发布的网站：如https://.github.io title：标题，显示在每个页面的左上，一般都是自己的id languageCode：页面语言，指定编码格式，比如en-us/en-gb/cn表示英语-美国/英语-英国 paginate：在主页上显示多少条博客内容 [markup]:这一部部分显示使用哪一种markup/down语法，它一般不会渲染HTML标签否则可能产生安全问题，但如果你想要强制使用的话：设置unsafe = true [params] - 基础的参数设置 header_image - 默认的所有页面的背景图片，并且固定作为home页面和about页面的图片 title - 文章标题，显示在每个页面 slogan - 子标题 sidebar_about_description, sidebar_avatar, \u0026 about_me：侧边栏介绍，侧边栏可以用于简单的自我介绍，提供一些个人简介之类的，而将about_me设置为true就可以实现了 featured_tags： 是用来指定有多少个tags你想在页面中显示 feature_condition_size：指定每篇文章最少要给出多少个tag在tag云中 image_404 \u0026 title_404 - 当文章找不到，显示的404图片 omit_categories - 是否要忽略导航栏分类功能 [[params.additional_menus]] - 提供在导航栏中提供额外的菜单，比如About页面 [params.social] - 社交账户设置 baseurl = \"https://fakeRichardWH.github.io\" title = \"fakeRichardWH\" theme = \"even\" languageCode = \"en-us\" paginate = 5000 #frontpage pagination [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [params] header_image = \"images/main_go_wideandtall_darklayer.jpeg\" title = \"Software Engineering\" slogan = \"$ grep -rni \\\"The how's and why's\\\" .\" SEOTitle = \"fakeRichardWH Blog\" keyword = \"fakeRichardWH, TestTools, MachineLEARNING, JAVA, SpringBoot\" # Sidebar settings sidebar_about_description = \"Husband, Skier, Cyclist, and, oh yeah, Software Developer\" sidebar_avatar = \"images/MeAtUS.jpeg\" about_me = true featured_tags = true featured_condition_size = 2 # 当有多少条post时可以实现按标签索引 (大于) image_404 = \"images/404-bg.jpg\" title_404 = \"We couldn't find what you were looking for...\" omit_categories = false [[params.addtional_menus]] title = \"ABOUT\" href = \"/top/about/\" [params.social] rss = true email = \"testMe@gmail.com\" linkedin = \"https://www.linkedin.com/in/richard-youngkin-0749763\" github = \"https://github.com/youngkin\" stackoverflow = \"https://stackoverflow.com/users/2646870/rich\" reddit = \"https://www.reddit.com/user/elevation5280\" 常用命令（Hugo及Git） ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:0","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"本地服务器启动 下面这个代码会启动一个本地的Hugo Web服务器 hugo server -D 输入后会显示： Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 我们之后可以用浏览器打开该网址看看写的文章： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:1","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":" 一个完整的工作流 （写博文/更改博文） 1.创建一个文档hugo new post/my-xxx-post.md，用markdown语法 （推荐用VScode + Markdown的扩展，可以本地及时查看博文变动） 2.本地测试文档，删除一些不必要的文件 3.使用hugo命令 4.使用git命令完成相应文章的上传/更新 #写完博文之后 hugo cd public git add . git commit -m \"blog added\" git push -u origin master #一般都是在master分支上去操作 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:2","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"总结一下Hugo命令 hugo -D #搭建静态页面 输出到 ./public 目录中 如果不另外指定的话 hugo server # 一般是用于本地web服务器校对 hugo #部署时使用 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:3:0","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Hugo"],"content":"content的目录结构 用下面一个样例结构来进行说明 content/ ├── about │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ │ ├── image1.jpg │ │ ├── image2.png │ │ └── index.md │ └── my-other-post │ └── index.md │ └── another-section ├── .. └── not-a-leaf-bundle ├── .. └── another-leaf-bundle └── index.md 上面这个是一个典型的四级目录包 about: 建立在root级别之下，其中只有一个index.md文件 my-post: image1: image2: my-other-post: ","date":"2021-11-03","objectID":"/post/hugocreatesite/:4:0","tags":["Hugo","Github","toml"],"title":"Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["leetcode"],"content":" 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –\u003e y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。你的代码只接受原链表的头节点head作为传入参数。 链表节点定义如下： // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1: 生成clone节点copyNode，用HashMap来存储\u003c原始Node,拷贝Node\u003e这样的键值对，存储起来 再去设置copyNode的random和next指针。 利用这个键值对的性质，每个拷贝Node的random指针需要指向的位置：就是原始Node的random指针指向那个Node的拷贝，而要找到这个值，就是利用hashmap.get(Node.random) 比如：1 -\u003e 2,1' -\u003e 2' 由于(1，1‘)构成了键值对，(2，2’)也构成了键值对，所以1‘的random需要指向2的拷贝2’ public class Solution1 { HashMap\u003cNode, Node\u003e map = new HashMap\u003c\u003e(); /** ** 思路1 */ public Node copyRandomList1(Node head) { Node cur = head; //利用 key 存放原链表节点,val 存放copyNode while (cur != null) { Node copyCur = new Node(cur.val); map.put(cur,copyCur); cur = cur.next; } cur = head; //对应设置好 next 和 random指针 while (cur != null) { Node copyCur = map.get(cur); //能这样设置的原因，就是提前将 (cur, copyCur)放入， //而每个cur能映射到它对应的copyCur copyCur.next = map.get(cur.next); copyCur.random = map.get(cur.random); cur = cur.next; } return map.get(head); } } 思路2: 对应每个原始链表的当前节点Cur生成Copy节点，将Copy节点放在原始链表的当前节点Cur的下一个位置nxt 再次遍历这个由新老节点构成的链表，设置Copy节点的random指针，它对应的random指向了Cur的random所指向的节点的下一个节点 最后我们只需要将原始链表从新构成的链表分离出来就可以了，返回的答案也要是新的拷贝链表的头节点 举个例子来说一个新构成的链表如下： 1 -\u003e 1' -\u003e 2 -\u003e 2' 假定原始链表中：2的random指向了1，那么在设置2‘的random时只需要将其指向1的next就可以了 //更省内存的方法 /** ** 思路2 */ public class Solution2 { public Node copyRandomList2(Node head) { if (head == null) { return null; } Node cur = head; Node nxt = null;//next指向原始链表中当前节点cur的下一个节点 Node copyCur = null; while (cur != null) { // 1 -\u003e 2 // cur nxt nxt = cur.next; // 1‘ 1 -\u003e 2 // copyCur cur nxt copyCur = new Node(cur.val); // 1 -\u003e 1‘ 2 // cur copyCur nxt cur.next = copyCur; // 1 -\u003e 1‘ -\u003e 2 // cur copyCur nxt copyCur.next = nxt; // 1 -\u003e 1' -\u003e 2 // cur cur = nxt; } //reset 回起点 cur = head; // 设置rand指针 while (cur != null) { // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur nxt copyCur = cur.next; nxt = cur.next.next; //一定要判断 cur.rand是否为null copyCur.random = cur.random != null ? cur.random.next : null; //移动copyCur和cur // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur cur = nxt; } //split 断开两个链表的连接 //先记下最终结果的头节点 Node res = head.next; cur = head; while (cur != null) { copyCur = cur.next; nxt = cur.next.next; // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur nxt // 1' -\u003e 2' // 1 -\u003e 2 copyCur.next = nxt != null ? nxt.next : null; cur.next = nxt; cur = nxt; } return res; } } ","date":"2021-02-10","objectID":"/post/leetcodeday05/:0:0","tags":["LinkedList"],"title":"leetcode-复制含有随机指针的链表-Copy Linkedlist with Random pointer","uri":"/post/leetcodeday05/"},{"categories":["leetcode"],"content":"二分查找绕口令 管他左侧还右侧，搜索区间定乾坤 搜索一个元素时，搜索区间两端闭 while条件带等号，否则需要打补丁 if相等就返回，其他的事甭操心 mid必须加减一，因为区间两端闭 while条件结束了，惨惨戚戚返-1； 搜索左右边界时，搜索区间要阐明 左闭右开最常见，其余逻辑便自明 while要用小于号，这样才能不漏掉 if相等别返回，利用mid锁边界 mid加一或减一？要看区间开活闭 while结束不算完，因为函数没返回 索引可能出边界，if检查保安全 左闭右开很常见，常见不一定合理 搜索区间心中记，或开或闭本无异 二分搜索三变体，逻辑统一记忆起 二分搜索框架 int binarySearch (int[] nums, int target) { int left = 0; int right = nums.length - 1;//也不一定是这个 看清题目要求 while (...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003e target) { right = ...; } else if (nums[mid] \u003c target) { left = ...; } } return ...; } 二分查找的代码一个极其重要的技巧就是：不要出现else，而是将所有情况用else if写清楚，清楚的展现出所有细节。 下面共有三种类型题： 寻找一个数（基本的二分搜索） 这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u003c= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; // 注意 else if (nums[mid] \u003e target) right = mid - 1; // 注意 } return -1;//如果是搜索插入位置 可以改为return left } 为什么while 循环中使用\u003c= 而非 \u003c ? 答： 因为初始化right的值是nums.length - 1，即最后一个元素的索引，而不是nums.length。 \u003c=或者\u003c可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小为nums.length是越界的。 这个算法中使用的是前者[left, right]两端都闭的区间。这个区间其实就是每次进行搜索的区间。 什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止： if(nums[mid] == target) { return mid; } 如果上述条件没有找到对应的target，则while循环会终止，返回-1。当while循环终止的时候，搜索区间为空：left == right + 1,写成区间的形式是：[right + 1, right]，例如[3,2]。 而如果循环条件是：while(left \u003c right) 可见此时终止条件为：left == right,搜索区间为[left, right],例如[2,2]。此时区间含有2这个索引，但是while循环已经终止了,所以该索引不会被搜索到，因此直接返回-1是错误的 如果一定要使用while(left \u003c right)那么就要做后处理 while(left \u003c right) { // ... ... } return nums[left] == target ? left : -1; 为什么left = mid + 1,right = mid -1? 因为本算法的搜索区间两端都是闭的，即[left, right],当索引mid不是target，下一步的搜索要么就是[mid + 1, right]或者[left, mid - 1],因为mid已经被搜索过，所以应该去除 3. 算法的局限性 比如说给一个有序数组nums = [1,2,2,2,3], target = 2,那么用上面的函数返回的索引是2，如果想要获取与target相同的最左侧边界，即索引1,那么就需要后处理，向左不断线性搜索，那么算法的复杂度可能就从$\\mathcal{O}(\\log(n))$变为$\\mathcal{O}(n)$级别的 寻找左侧边界的二分搜索 ","date":"2021-02-09","objectID":"/post/leetcodeday06/:0:0","tags":["Binary Search"],"title":"leetcode-二分查找模版BinarySearch","uri":"/post/leetcodeday06/"},{"categories":["leetcode"],"content":"左边界-原始代码 int findLeftBound(int[] nums, int target) { if (nums == null || nums.length == 0) return -1; int left = 0; int right = nums.length; //注意这是 nums.length while (left \u003c right) {//注意是小于号 int mid = (left + right) / 2; if (nums[mid] == target) {//调整右边界 right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; // 注意 } } return left;//注意这个返回值需要改变 } 为什么 while 中是 \u003c 而不是 \u003c=? 答：用相同的方法分析，因为right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left \u003c right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以是一个正确的终止。 PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的right 不是nums.length - 1吗，为啥这里非要写成 nums.length使得「搜索区间」变成左闭右开呢？ 因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。 为什么没有返回-1的操作？如果nums中不存在target这个值，怎么办？ 对于这个数组，算法会返回1,而这个1可以解读为nums中中小于2的元素有1个。 比如对于有序数组nums = [2,3,5,7], target = 1，算法会返回0，含义是：nums中小于1的元素有0个。 再比如说 nums = [2,3,5,7], target = 8，算法会返回4，含义是：nums 中小于8的元素有4个。综上可以看出，函数的返回值（即left变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1 while (left \u003c right) { //... } if (nums[left] \u003c target) { return -1; } //target大于所有数组中的数 /** 上面这个if语句的等价写法 * if (left == nums.length) return -1; */ return nums[left] == target ? left : -1; 为什么left = mid + 1，right = mid？和之前的算法不一样？ 答：这个很好解释，因为我们的「搜索区间」是[left, right)左闭右开，所以当nums[mid]被检测之后。 下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。 4. 为什么该算法能够搜索左侧边界？ 答：关键在于对于 nums[mid] == target 这种情况的处理： if (nums[mid] == target) right = mid; 当我们找到target时，不是立刻返回，而是不断缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 5、为什么返回 left 而不是 right？ 答：都是一样的，因为 while 终止的条件是 left == right。 能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。 答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改： 因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 \u003c=： int findLeftBound(int[] nums, int target) { // 搜索区间为 [left, right] int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; // if else ... } 因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下： if (nums[mid] \u003c target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u003e target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } 由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界： 因此，最后返回结果时，代码需要检查越界情况： if (left \u003e= nums.length || nums[left] != target) { return -1; } return left; ","date":"2021-02-09","objectID":"/post/leetcodeday06/:1:0","tags":["Binary Search"],"title":"leetcode-二分查找模版BinarySearch","uri":"/post/leetcodeday06/"},{"categories":["leetcode"],"content":"左边界 最终代码 所以最终的代码完整如下： int findLeftBound(int[] nums, int target) { int left = 0, right = nums.length - 1; // 搜索区间为 [left, right] while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u003e target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } } // 检查出界情况 if (left \u003e= nums.length || nums[left] != target) return -1; return left; } 这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。 寻找右侧边界 类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注： int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } return left - 1; // 注意 } 为什么能找到右侧边界？ if (nums[mid] == target) { left = mid + 1; // 注意这里 当nums[mid] == target时,不是立刻返回mid,而是而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。 答：while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回right - 1好了。 至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个判断条件： if (nums[mid] == target) { left = mid + 1; // 注意这里 这之后，left被更新为left = mid + 1，就是说while循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。见下图： 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1: while (left \u003c right) { // ... } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; 是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 这里改为检查 right 越界的情况，见下图 if (right \u003c 0 || nums[right] != target) return -1; return right; } 当target比所有的元素都小时，right会减小到-1,如下图： 总结 来梳理一下这些细节差异的因果逻辑： 第一个，最基本的二分查找算法： 因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u003c= right) 同时也决定了更新方式是: left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回 第二个，寻找左侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u003c right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界 第三个，寻找右侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u003c right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一 ","date":"2021-02-09","objectID":"/post/leetcodeday06/:2:0","tags":["Binary Search"],"title":"leetcode-二分查找模版BinarySearch","uri":"/post/leetcodeday06/"},{"categories":["leetcode"],"content":"Q1: 判断一个链表 是否属于回文结构 // example1 input: 1 -\u003e 2 -\u003e 23 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example2 input: 1 -\u003e 2 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example3 input: 1 -\u003e 2 -\u003e 23 -\u003e 3 -\u003e 1 output: false ","date":"2021-02-08","objectID":"/post/leetcodeday04/:0:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构-Palindrome LinkedList","uri":"/post/leetcodeday04/"},{"categories":["leetcode"],"content":"思路一: ","date":"2021-02-08","objectID":"/post/leetcodeday04/:1:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构-Palindrome LinkedList","uri":"/post/leetcodeday04/"},{"categories":["leetcode"],"content":"利用一个stack来实现 Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(n)$ 将链表以中点部分为界的后半部分逐个压栈，如果遇到中点就停止入栈。 然后从中点位置开始依次弹出栈元素，同时重头开始遍历链表,将链表中的元素与栈元素比较，如果不相同返回false否则返回true 注意奇/偶长度的链表情况下：slow指针停下的位置，以及stack是否应该添加当前位置的值 public boolean ifPalindrome (Node head) { if (head == null || head.next == null) { return true; } Deque\u003cInteger\u003e stack = new ArrayDeque\u003cInteger\u003e(); //先找到中点 Node midPoint = findMid(head); Node cur = head; while (cur != midPoint.next) { stack.push(cur.val); cur = cur.next; } return true; } //奇偶条件下 slow指针的位置 // 1-\u003e2-\u003e2-\u003e1-\u003enull // s s // f f // 1-\u003e2-\u003e1-\u003enull // s s // f f private Node findMid(Node head) { if(head == null || head.next) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } ","date":"2021-02-08","objectID":"/post/leetcodeday04/:1:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构-Palindrome LinkedList","uri":"/post/leetcodeday04/"},{"categories":["leetcode"],"content":"思路二: ","date":"2021-02-08","objectID":"/post/leetcodeday04/:2:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构-Palindrome LinkedList","uri":"/post/leetcodeday04/"},{"categories":["leetcode"],"content":" Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(1)$ 用快慢指针法找到链表的中点，然后将链表的后半段进行反转，然后cur1从头节点开始遍历，cur2从中点开始遍历，如果cur1指针所指向的值不等于cur2指针的值，那么就返回false，否则返回true，最好在返回时还能够将原链表复原 public Node ifPalindromeList(Node head) { if(head == null || head.next == null) { return true; } Node mid = findMid(head); Node head2 = reverseList(mid.next); //注意要断开 mid 和 mid.next 之间的联系 mid.next = null; Node cur2 = head2; Node cur1 = head; //就算是奇数个节点也没有问题 //因为奇数个节点的时候 其中cur2会走到null //而cur1会走到链表中点的位置 while (cur1 != null \u0026\u0026 cur2 != null) { if (cur1.val != cur2.val) { return false; } cur1 = cur1.next; cur2 = cur2.next; } head2 = reverseList(head2); mid.next = head2; return true; } private Node findMid(Node head) { if(head == null || head.next == null) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } private Node reverseList(Node head) { if (head == null || head.next == null) { return head; } Node pre = null; Node cur = head; Node nxt = head.next; // 1 -\u003e 2 -\u003e null // cur nxt while (nxt != null) { cur.next = pre; pre = cur; cur = nxt; nxt = nxt.next; } cur.next = pre; return cur; } ","date":"2021-02-08","objectID":"/post/leetcodeday04/:2:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构-Palindrome LinkedList","uri":"/post/leetcodeday04/"}]