[{"categories":["文件读取","pandas"],"content":"pandas数据读取 Pandas读取表格类型的数据然后进行分析,支持的数据类型和读取方法如下 数据类型 格式 读取方法 csv, tsv, txt 用逗号分隔或者tab分隔的纯文本文件 pd.read_csv() excel 微软的xls/xlsx文件 pd.read_excel() mySQL 关系型数据库表 pd.read_sql() 读取纯文本文件 ","date":"2022-02-11","objectID":"/post/pandas02/:0:0","tags":["pandas","Python"],"title":"pandas02","uri":"/post/pandas02/"},{"categories":["文件读取","pandas"],"content":"1.1 读取csv,使用默认的标题行 一个DataFrame中,最左侧的是index,最上方的是columns(列名),中间的部分是data fpath = \"./ratings.csv\" ratings = pd.read_csv(fpath) # 查看数据的前10行 ratings.head(10) # 查看数据的形状 返回值为 (行数,列数) ratings.shape Out[2]: (100836,4) # 查看列名的列表 ratings.columns Out[3]: Index(['userID','movieID','rating','timestamp'], dtype = 'object') # 查看每一列的数据类型 ratings.dtypes Out[4]: 'userID': int64 'movieID': int64 'rating': float64 'timestamp': int64 dtype: object ","date":"2022-02-11","objectID":"/post/pandas02/:1:0","tags":["pandas","Python"],"title":"pandas02","uri":"/post/pandas02/"},{"categories":["文件读取","pandas"],"content":"1.2 读取txt文件,自定义分隔符和列名 fpath = \"./test.txt\" test = pd.read_csv( fpath, sep = '\\t' # 定义分隔符 使用正则表达式 header = None, # 没有标题行 所以设置为None names = ['birthDate', 'age', 'name'] # 定义列名 一定要和原数据一致 方便后续根据列名筛选数据 ) 读取excel文件 fpath = \"./test2.xlsx\" test2 = pd.read_excel(fpath) 读取MySQL数据库 import pymysql # 利用pymysql获取与数据库的连接 conn = pymsql.connect( host = \"127.0.0.1\", user = \"root\", password = \"123456\", database = \"db1\", charset = \"utf8\" ) # 传入两个参数: # 第一个参数是String类型的SQL语句 # 第二个参数是数据库的一个连接 db1 = pd.read_sql(\"select * from tableName1\", con = conn) db1 ","date":"2022-02-11","objectID":"/post/pandas02/:2:0","tags":["pandas","Python"],"title":"pandas02","uri":"/post/pandas02/"},{"categories":["leetcode","java"],"content":"广度优先搜索模版 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:0:0","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"核心思路 BFS核心思想就是把问题抽象为一个图，从一个节点开始，向四周扩散。一般来说，BFS都会使用到一个队列，这样就可以将一个节点周围的所有节点加入队列。 BFS相较于DFS（回溯算法）,但代价就是空间复杂度要比DFS高。 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:1:0","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"算法框架 问题的本质就是在一个图中，从起点start找到终点target的最短距离，BFS的本质就是干这个事情。这个问题的描述可以有各种变体： 走迷宫、岛屿数量。这类问题会添加限定条件比如某些位置不能走。 有两个单词，给出一些固定/非固定的替换，将其中一个变为另一个，每次能替换一个字符，最少要替换几次？ 连连看，点击两个坐标，如何判断两者中的最短连线有几个拐点？ // 计算起点 start 到终点 target 的最近距离 int bfs(Node start, Node target) { Deque\u003cNode\u003e q; //核心数据结构：队列 Set\u003cNode\u003e visited; // 避免重复访问 走回头路 // 将起点加入 初始队列 q.offer(start); visited.add(start); int step = 0; // 记录当前扩散到哪一步？ while (!q.isEmpty() ) { //队列不为空 int size = q.size(); //记录当前队列扩散了多少个节点 /* 将当前队列中的所有节点向四周扩散 */ // 当前层 加入 queue for（int i = 0; i \u003c size; i++) { Node cur = q.poll(); if (cur is target) { /* 判断是否是终点 */ return step;// 最短路径生成 } /* 当前节点的相邻节点加入队列中*/ for (Node x : cur.adjacent()) { q.offer(x); visited.add(x); } } //当前层遍历完 step++;//对最短路径长度更新 } // 队列为空，广度搜索结束 } 队列q就不说了，BFS的核心数据结构；cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。 至于为啥这样就一定是最短的路径呢，可以用反证法的思维，假设扩散到某一层的target位置已经是最短路径了，那么前面的层一定不包含target，否则就会终止扩散。 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:2:0","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"二叉树的最小高度 给定一个二叉树，找出其最小的深度，最小深度就是指从根节点到最近的叶子节点的节点数量。 叶子节点就是左右子节点都为null ","date":"2022-01-27","objectID":"/post/leetcodeday03/:3:0","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"思考的逻辑： 如何套用到BFS呢？ 明确起点 start 及终点 target 分别是什么，并且在什么条件下到达了终点 队列存储的是一系列待扩散的节点，利用for循环遍历队列中的节点，并且判断是否达到了目标节点 那在这里，起点就是root，终点就是叶节点，怎么判断是否到了叶节点？ if (cur.left == null \u0026\u0026 cur.right == null) int minHeight(TreeNode root) { Linkedlist\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); //HashSet\u003cTreeNode\u003e visited = new HashSet\u003c\u003e(); 不再是必要的了 因为二叉树不会重复访问 if (root == null) { return 0; } queue.offer(root); int minHeight = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u003c size; i++) { TreeNode cur = queue.poll(); if (cur.left == null \u0026\u0026 cur.right == null) { return minHeight; } // 否则就再将节点的左子树节点加入到队列中 if (cur.left != null) { queue.offer(cur.left); } if (cur.left != null) { queue.offer(cur.right); } } minHeight++; } } ","date":"2022-01-27","objectID":"/post/leetcodeday03/:3:1","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"岛屿数量 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。 一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设网格的四个边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 (总共有1个岛屿) 示例 2: 输入: 11000 11000 00100 00011 输出: 3 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:4:0","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"大体思路1: 深度优先遍历： 1.初始状态所有顶点都没被访问，从每一个顶点v出发，先访问该顶点v 2.依次从 v 的各个 未被访问visited[i][j] == false的临接顶点出发，以相同的逻辑遍历图，直到图中所有和v相通的顶点都被访问到 3.遍历完后，还有其他的点没有被访问到，则另选一个未被访问的顶点作为起始点 4.重复上述过程，直至所有点被访问 本题思路，上下左右相连为1的才被认为是连续岛屿 DFS方式： 设定目前指向一个岛屿中的某个点(i, j),寻找包含此点的边界 1.1 从 (i, j)向此点的上下左右 (i + 1, j)，(i - 1, j)，(i, j + 1)，(i, j - 1)做深度搜索 1.2 终止条件： 1.2.1 (i, j)越过了矩阵的边界 1.2.2 grid[i][j] == 0，代表此时分支已经越过了岛屿边界 ","date":"2022-01-27","objectID":"/post/leetcodeday03/:4:1","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["leetcode","java"],"content":"代码实现 package leetcode; import java.util.*; public class Main { static int[][] island; static int[] dx = {-1, 0, 1, 0}; static int[] dy = {0, -1, 0, 1}; static int rows; static int cols; static boolean[][] visited; // 要构建一个和岛屿大小数量一致的数组 public static void main(String[] args) { Scanner sc = new Scanner(System.in); List\u003cString\u003e list = new ArrayList\u003c\u003e(); while(sc.hasNextLine()) { list.add(sc.nextLine()); } rows = list.size(); cols = list.get(0).length(); island = new int[rows][cols]; for (int i = 0; i \u003c rows; i++) { for(int j = 0; j \u003c cols; j++) { island[i][j] = list.get(i).charAt(j); } } System.out.println(Arrays.deeptoString(island)); } } ","date":"2022-01-27","objectID":"/post/leetcodeday03/:4:2","tags":null,"title":"Leetcode03","uri":"/post/leetcodeday03/"},{"categories":["machine learning"],"content":"朴素贝叶斯 解决的是多分类问题 边缘概率 $P(X) = \\sum_{Y}P(X,Y)$ 从直观上理解这个式子，要消除随机变量Y对联合概率的影响，那么就要固定每个Y，对联合概率求和，从而消除X的影响 条件概率 $P(X, Y) = P(Y|X)P(X) = P(Y|X)P(X)$ $P(Y|X)$中由于X作为条件已经被确定了，那么减少（消除）了一部分的不确定性，而两个变量的联合不确定性更大，所以需要补充的就是X的不确定性 $P(X,Y,Z) = P(X|Y,Z)P(X,Y|Z)P(Z)$ $P(X,Y,Z)$的联合概率分布，需要的是以X为变量，将Y，Z作为确定条件来降低不确定性，而补充这一不确定性需要当Z确定时的X，Y的不确定性和Z单独的不确定性 引入条件独立性假设 $P(X, Y) = P(Y)P(X)$ 此时由于X，Y是相互独立的，所以X无论确定还是不确定，对Y的条件概率无影响，从而可以将朴素贝叶斯推出来 条件独立性假设：在标签一定(被确定)的基础上，X向量或者说特征向量，各个特征之间相互独立 $P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)}, …,X^{(n)}=x^{(n)}| Y = c_{k}) = \\prod_{i}^{n}P(X^{(i)}=x^{(i)}|Y)$ 从而： $P(X=\\bf{x}|Y = c_{k}) = \\prod_{i}^{n}P(X^{(i)}=x^{(i)}|Y)$ 贝叶斯估计 由于我们的采样的数据集可能偏向于只有某一类别的数据，导致某个类别的概率（频率）为0 XGBoost 由于它计算的准而且快，所以用在各大比赛当中使用的多，不要迷信深度学习 xGBoost = extreme + GBDT = extreme + Gradient + BoostDT Boosting -\u003e Boosting DT -\u003e gradient BDT -\u003e 使用了一阶梯度信息 ","date":"2022-01-26","objectID":"/post/ml01/:0:0","tags":["原理","机器学习"],"title":"Pandas中loc和iloc区别","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"所谓的最优函数其实是由参数决定的，其实学习方式是用最优参数。构建了模型，然后对参数求偏导。但如果没有模型参数，只有f(x)，那我们也可以只对函数本身求偏导 ","date":"2022-01-26","objectID":"/post/ml01/:1:0","tags":["原理","机器学习"],"title":"Pandas中loc和iloc区别","uri":"/post/ml01/"},{"categories":["machine learning"],"content":"如何理解梯度提升算法？ 关键在于梯度提升算法使用的不再是基于参数的负梯度，而是基于模型的损失函数的负梯度作为下次迭代中残差的近似值 $\\argmin$ ","date":"2022-01-26","objectID":"/post/ml01/:2:0","tags":["原理","机器学习"],"title":"Pandas中loc和iloc区别","uri":"/post/ml01/"},{"categories":["loc","iloc","pandas"],"content":"loc vs iloc loc函数：通过行索引 “Index” 中的具体值来取行数据（如取\"Index\"为\"A\"的行）可以认为是利用行名称来提取，方便记忆 而且当index具备特殊意思的时候： 例如 当index是人名时,会将所有相同人名字的信息提取出来 iloc函数：通过具体的行号来取行数据（如取第二行的数据）利用纯粹的下标索引找行数据，如果当对行名称不记得的时候可以使用 ","date":"2022-01-26","objectID":"/post/pandas01/:0:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"五种使用方法 本文给出loc、iloc常见的五种用法，并附上详细代码。 import numpy as np import pandas as pd # create a dataframe data = pd.DataFrame(np.arange(16).reshape(4, 4), index = list(\"abcd\"), columns = list(\"ABCD\")) In [6]: data Out[6]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 ","date":"2022-01-26","objectID":"/post/pandas01/:1:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"1. 取一整行数据 取出索引为“a”的行 data.loc[\"a\"] In [7]: data.loc[\"a\"] Out[7]: A 0 B 1 C 2 D 3 Name: a, dtype: int64 取出第一行数据(index == 0)，也就是索引为“a”的数据 In [8]: data.iloc[0] Out[8]: A 0 B 1 C 2 D 3 Name: a, dtype: int64 ","date":"2022-01-26","objectID":"/post/pandas01/:2:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"2. 取指定的行 和 列 数据 利用 loc 根据行和列的索引名称 获取 In [9]: data.loc[[\"a\",\"b\"],[\"A\",\"B\"]] Out[9]: A B a 0 1 b 4 5 在不知道数据分布情况下：使用行和列索引下标查询 In [10]: data.iloc[[0,1],[0,1]] Out[10]: A B a 0 1 b 4 5 ","date":"2022-01-26","objectID":"/post/pandas01/:3:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"3. 提取某一列的所有行数据 使用loc查询某一列所有行数据 In [11]: data.loc[:,[\"A\"]] Out[11]: A a 0 b 4 c 8 d 12 使用iloc查询某一列的所有信息 # 注意传入的参数都是 list In [12]: data.iloc[:,[0]] Out[12]: A a 0 b 4 c 8 d 12 ","date":"2022-01-26","objectID":"/post/pandas01/:4:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"4. 利用loc/iloc提取所有数据 In [13]: data.loc[:,:] Out[13]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 In [14]: data.iloc[:,:] Out[14]: A B C D a 0 1 2 3 b 4 5 6 7 c 8 9 10 11 d 12 13 14 15 ","date":"2022-01-26","objectID":"/post/pandas01/:5:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["loc","iloc","pandas"],"content":"5.利用loc函数，根据某个筛选条件来提取数据所在行 单个条件查询 In [15]: data.loc[data[\"A\"] == 0] # data[\"A\"]相当于拿出A一整列 Out[15]: A B C D a 0 1 2 3 # 获取相同的数据其他方法 # 使用dataframe访问方法 In [19]: data[data[\"A\"] == 0] Out[19]: A B C D a 0 1 2 3 # 使用df.isin([ value]) 方法 In [20]: data[data[\"A\"].isin([0])] Out[20]: A B C D a 0 1 2 3 多条件筛选 多个条件之间一定要加括号 否则会出错 In [17]: data.loc[(data[\"A\"] == 0) \u0026 (data[\"B\"] == 2)] Out[17]: Empty DataFrame Columns: [A, B, C, D] Index: [] # 使用isin()的查询方式 In [23]: data[(data[\"A\"].isin([0])) \u0026 (data[\"B\"].isin([2])) ] Out[23]: Empty DataFrame Columns: [A, B, C, D] Index: [] ","date":"2022-01-26","objectID":"/post/pandas01/:6:0","tags":["pandas","Python"],"title":"Pandas中loc和iloc区别","uri":"/post/pandas01/"},{"categories":["匿名函数","Python"],"content":"匿名函数 以lambda 作为关键字,可以在一行内完成定义和声明，这个匿名函数由于没有实际的名称，所以一般在Python中没有什么复杂的功能。 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:0:0","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"语法 lambda arg1, arg2, arg3 ... : \u003cexpression\u003e 其中 arg1,arg2,arg3是函数的输入参数，而\u003cexpression\u003e则是函数体，运算结果就是表达式结果。 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:1:0","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"例子 # 输入是x,y; 输出是x*y lambda x, y : x*y # 输入是空; 输出是None lambda : None # 输入是任意个数的参数（以tuple传入），但是隐含条件需要这些参数可以相加 lambda *args : sum(args) ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:1:1","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"使用 lambda往往有下面三种常用的使用方式 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:2:0","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"赋值给其他变量 例如，执行语句 add = lambda x, y: x+y 定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:2:1","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"替换其他函数 例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用： time.sleep = lambda x : None 。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行time.sleep(3)时，程序不会休眠3秒钟，而是什么都不做。 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:2:2","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"作为返回值 由于函数的返回值也可以是函数。例如 def cal(x, y): x = x**2 y = 1 return lambda x, y: x+y 返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:2:3","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["匿名函数","Python"],"content":"内置函数接受lambda表达式 filter函数 filter(function, iterable)函数本身传入的第一个参数为函数名，第二参数为可迭代对象，返回值是可迭代对象 lambda用来作为指定过滤列表元素的条件。 import numpy as np list1 = np.arange(3) filter(lambda x : x % 2 == 0, list1) # result: [0,2] sorted函数 sorted(iterable, key = function)函数本身是对iterable对象中所有元素按照function排序 lambda用来作为指定的排序条件。 import numpy as np arr = np.arange(9) print(sorted(arr, key = lambda x : abs(5 - x))) # result: [5, 4, 6, 3, 7, 2, 8, 1, 0] # 结果是依次排序数组中离5最近的元素值 map函数 map(function, iterable)函数本身是对iterable对象中所有元素按照function排序 lambda用于指定对列表中每一个元素的相同映射操作。 import numpy as np list = np.arange(9) sqr = map(lambda x : x**2, list) print([x for x in sqr]) # result: [0, 1, 4, 9, 16, 25, 36, 49, 64] # 对[0,9]逐元素平方 ","date":"2022-01-21","objectID":"/post/pythonusefulfunc/:2:4","tags":null,"title":"Lambda函数使用","uri":"/post/pythonusefulfunc/"},{"categories":["leetcode","java"],"content":"题目 前提条件： 两个有序数组均为正序列，且两个数组有且仅有一个会是空数组 nums1.length = m,nums1.length = n 如果m+n == 2k,那么中位数为第k和k+1位置的数据的之和的一半 也就是$\\frac{m + n}{2}$ 和$\\frac{m + n}{2} + 1$ 如果m+n == 2k+1,那么中位数为k+1位置的数据 $\\frac{m + n}{2} + 1$ 分析 给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种： 注意： 当两个数组长度之和为偶数时，其中位数为总长度n的$\\frac{n - 2}{2}$位置上和$\\frac{n}{2}$位置上的取值之和的一半 当两个数组长度之和为偶数时，其中位数为总长度n的$\\frac{n}{2}$位置上的数值 思路1: 使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数 public double findMedianSortedArray(int[] nums1, int[] nums2) { int[] nums = new int[nums1.length + nums2.length]; int m = nums1.length; int n = nums2.length; //special case if (m == 0) { if (n % 2 == 0) {//长度为偶数 return (nums2[n / 2 - 1] + nums2[n / 2]) /2.0; } else { return (double) nums2[n / 2]; } } if (n == 0) { if (m % 2 == 0) {//长度为偶数 return (nums2[m / 2 - 1] + nums2[m / 2]) /2.0; } else { return (double) nums2[m / 2]; } } //合并两个有序数组 int count = 0; int i = 0, j = 0; while (count != (m + n)) {//这个逻辑不是唯一的 //可以改写 if (i == m) {//nums1 的指针已经到了边界 while (j != n) { nums[count++] = nums2[j++]; } } if (j == n) {//nums2 的指针已经到了边界 while (i != m) { nums[count++] = nums2[i++]; } } if (nums1[i] \u003c= nums2[j]) { nums[count++] = nums1[i++]; } else { nums[count++] = nums1[j++]; } } //返回合并后数组中位数 if (count % 2 == 0) {//长度为偶数 return (nums2[count / 2 - 1] + nums2[count / 2]) /2.0; } else { return (double) nums2[count / 2]; } } 思路2: 我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。 开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了for循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。 首先是怎么将奇数和偶数的情况合并一下。 用 len 表示合并后数组的长度: 如果是奇数，我们需要知道第 (len+1）/2 个数就可以了，如果遍历的话需要遍历 (int) (len/2) + 1 次。比如len长度为5,那么我们要拿到第三个数，需要遍历三次 如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。比如len长度为6,那么我们要拿到第三个和第四个数,可以遍历四次然后减1,拿到左边的数字 返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量pre和cur，cur保存当前循环的结果，在每次循环前将cur的值赋给pre。这样在进行最后一次循环的时候,pre将得到 cur的值，也就是上一次循环的结果，接下来cur更新为最后一次的结果。 循环中该怎么写，什么时候nums1数组后移，什么时候nums2数组后移。用p1和p2分别表示当前指向nums1数组和nums2数组的位置。如果p1还没有到最后并且此时nums1位置的数字小于nums2位置的数组，那么就可以后移了。也就是p1 ＜ m \u0026\u0026 nums1[p1]\u003c nums2[p2]。 但如果nums2数组此刻已经没有数字了，继续取数字nums2[p2]，则会越界，所以判断下p2是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 p1 ＜ m \u0026\u0026 (p2 \u003e= n || nums1[p1] \u003c nums2[p2]) 。其中p2 \u003e= n的优先级更高，因为即便这个条件为假也不妨碍后面的为真时的结果，但是这个如果为真，那就一定要移动p1指针了。 public double findMedianSortedArray(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int len = len1 + len2; int p1 = 0, p2 = 0;//设置两个数组指针 //设置记录值的容器 int cur = -1, pre = -1;//cur记录中位数 while (int i = 0; i \u003c len / 2; i++) {//循环 (len / 2) + 1 次 pre = cur; //每次遍历前 将上一轮的值赋给 pre if (p1 \u003c len1 \u0026\u0026 (p2 \u003e= len2 || nums1[p1] \u003c nums2[p2])) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } } //退出循环时 判断一下数组总长度 // 如果是偶数 if ((len \u0026 1) == 0) {//相当于进行了取余运算 return (pre + cur) / 2.0; } return (double) cur; } ","date":"2022-01-12","objectID":"/post/leetcodeday02/:0:0","tags":null,"title":"LeetcodeDay02","uri":"/post/leetcodeday02/"},{"categories":["leetcode","java"],"content":"两数之和 ","date":"2022-01-11","objectID":"/post/leetcodeday01/:0:0","tags":null,"title":"LeetcodeDay01","uri":"/post/leetcodeday01/"},{"categories":["leetcode","java"],"content":"思路1: 思路一: 对于nums数组中每个位置i上的x，要找到target-x,可以使用两层遍历，第一层遍历是遍历数组中的每个数字，第二层遍历是从该位置的后一个位置j = i + 1开始查看是否符合target - x 时间复杂度: $o(n^2)$ 空间复杂度: $o(1)$ public class Solution { public static void main(String[] args) { int[] nums = new int[]{1,3,2,4}; int target = 5; int[] result = find2Sum(nums, target); } public static int[] find2Sum(int[] nums, int target) { if (nums == null || nums.length \u003c= 1) { return null; } for (int i = 0; i \u003c nums.length; i++) { rest = target - nums[i]; for (int j = i + 1; j \u003c nums.length; j++) { if (nums[j] == rest) { return new int[]{i, j}; } } } return null; } } ","date":"2022-01-11","objectID":"/post/leetcodeday01/:1:0","tags":null,"title":"LeetcodeDay01","uri":"/post/leetcodeday01/"},{"categories":["leetcode","java"],"content":"思路2: 思路二:利用HashMap查询key只要o(1)时间的特性.我们将每个位置的数字nums[i]和其对应的索引i存入HashMap中，每次遍历过程遇到一个数字将(nums[i], i)键值对存储之前，先查询这个数字对应的target - nums[i]是否在HashMap中已经存储， 如果没有，那么就存入这个数字，遍历下一个数字 如果存在，说明当前数字和能找到对应的数字构成target 时间复杂度: $o(n)$ 空间复杂度: $o(n)$ ","date":"2022-01-11","objectID":"/post/leetcodeday01/:2:0","tags":null,"title":"LeetcodeDay01","uri":"/post/leetcodeday01/"},{"categories":["leetcode","java"],"content":"注意： HashMap创建时需要用到泛型 HashMap提供了 boolean containsKey(Integer key) 和 Integer get(Integer key)方法 import java.util.HashMap; public class Solution { public static void main(String[] args) { int[] nums = new int[]{1,3,2,4}; int target = 5; int[] result = find2Sum(nums, target); } public static int[] find2Sum(int[] nums, int target) { int[] result = new int[2]; HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{i, map.get(target - nums[i])}; } else { map.put(nums[i], i); } } return null; } ","date":"2022-01-11","objectID":"/post/leetcodeday01/:2:1","tags":null,"title":"LeetcodeDay01","uri":"/post/leetcodeday01/"},{"categories":null,"content":"VSCODE快捷键配置 [Mac] 下载好Markdown All in One这个插件后： 先输入Command + Shift + p : ，再找到默认键盘设置:(Open Default Keyboard Shortcut Settings JSON)，然后一一设置即可 ","date":"2021-12-22","objectID":"/post/shortcuts/:0:0","tags":["shortcuts","VSCODE"],"title":"Shortcuts","uri":"/post/shortcuts/"},{"categories":null,"content":"自动切换为代码块 option(alt) + 0: 切换（添加）代码行 option(alt) + shift + 0:切换（添加）代码块 ","date":"2021-12-22","objectID":"/post/shortcuts/:1:0","tags":["shortcuts","VSCODE"],"title":"Shortcuts","uri":"/post/shortcuts/"},{"categories":null,"content":"二分查找绕口令 管他左侧还右侧，搜索区间定乾坤 搜索一个元素时，搜索区间两端闭 while条件带等号，否则需要打补丁 if相等就返回，其他的事甭操心 mid必须加减一，因为区间两端闭 while条件结束了，惨惨戚戚返-1； 搜索左右边界时，搜索区间要阐明 左闭右开最常见，其余逻辑便自明 while要用小于号，这样才能不漏掉 if相等别返回，利用mid锁边界 mid加一或减一？要看区间开活闭 while结束不算完，因为函数没返回 索引可能出边界，if检查保安全 左闭右开很常见，常见不一定合理 搜索区间心中记，或开或闭本无异 二分搜索三变体，逻辑统一记忆起 二分搜索框架 int binarySearch (int[] nums, int target) { int left = 0; int right = nums.length - 1;//也不一定是这个 看清题目要求 while (...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003e target) { right = ...; } else if (nums[mid] \u003c target) { left = ...; } } return ...; } 二分查找的代码一个极其重要的技巧就是：不要出现else，而是将所有情况用else if写清楚，清楚的展现出所有细节。 下面共有三种类型题： 寻找一个数（基本的二分搜索） 这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u003c= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; // 注意 else if (nums[mid] \u003e target) right = mid - 1; // 注意 } return -1;//如果是搜索插入位置 可以改为return left } 为什么while 循环中使用\u003c= 而非 \u003c ? 答： 因为初始化right的值是nums.length - 1，即最后一个元素的索引，而不是nums.length。 \u003c=或者\u003c可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小为nums.length是越界的。 这个算法中使用的是前者[left, right]两端都闭的区间。这个区间其实就是每次进行搜索的区间。 什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止： if(nums[mid] == target) { return mid; } 如果上述条件没有找到对应的target，则while循环会终止，返回-1。当while循环终止的时候，搜索区间为空：left == right + 1,写成区间的形式是：[right + 1, right]，例如[3,2]。 而如果循环条件是：while(left \u003c right) 可见此时终止条件为：left == right,搜索区间为[left, right],例如[2,2]。此时区间含有2这个索引，但是while循环已经终止了,所以该索引不会被搜索到，因此直接返回-1是错误的 如果一定要使用while(left \u003c right)那么就要做后处理 while(left \u003c right) { // ... ... } return nums[left] == target ? left : -1; 为什么left = mid + 1,right = mid -1? 因为本算法的搜索区间两端都是闭的，即[left, right],当索引mid不是target，下一步的搜索要么就是[mid + 1, right]或者[left, mid - 1],因为mid已经被搜索过，所以应该去除 3. 算法的局限性 比如说给一个有序数组nums = [1,2,2,2,3], target = 2,那么用上面的函数返回的索引是2，如果想要获取与target相同的最左侧边界，即索引1,那么就需要后处理，向左不断线性搜索，那么算法的复杂度可能就从$\\mathcal{O}(\\log(n))$变为$\\mathcal{O}(n)$级别的 寻找左侧边界的二分搜索 ","date":"2021-12-21","objectID":"/post/binarysearch/:0:0","tags":["算法","Java"],"title":"BinarySearch","uri":"/post/binarysearch/"},{"categories":null,"content":"左边界-原始代码 int findLeftBound(int[] nums, int target) { if (nums == null || nums.length == 0) return -1; int left = 0; int right = nums.length; //注意这是 nums.length while (left \u003c right) {//注意是小于号 int mid = (left + right) / 2; if (nums[mid] == target) {//调整右边界 right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; // 注意 } } return left;//注意这个返回值需要改变 } 为什么 while 中是 \u003c 而不是 \u003c=? 答：用相同的方法分析，因为right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left \u003c right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以是一个正确的终止。 PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的right 不是nums.length - 1吗，为啥这里非要写成 nums.length使得「搜索区间」变成左闭右开呢？ 因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。 为什么没有返回-1的操作？如果nums中不存在target这个值，怎么办？ 对于这个数组，算法会返回1,而这个1可以解读为nums中中小于2的元素有1个。 比如对于有序数组nums = [2,3,5,7], target = 1，算法会返回0，含义是：nums中小于1的元素有0个。 再比如说 nums = [2,3,5,7], target = 8，算法会返回4，含义是：nums 中小于8的元素有4个。综上可以看出，函数的返回值（即left变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1 while (left \u003c right) { //... } if (nums[left] \u003c target) { return -1; } //target大于所有数组中的数 /** 上面这个if语句的等价写法 * if (left == nums.length) return -1; */ return nums[left] == target ? left : -1; 为什么left = mid + 1，right = mid？和之前的算法不一样？ 答：这个很好解释，因为我们的「搜索区间」是[left, right)左闭右开，所以当nums[mid]被检测之后。 下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。 4. 为什么该算法能够搜索左侧边界？ 答：关键在于对于 nums[mid] == target 这种情况的处理： if (nums[mid] == target) right = mid; 当我们找到target时，不是立刻返回，而是不断缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 5、为什么返回 left 而不是 right？ 答：都是一样的，因为 while 终止的条件是 left == right。 能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。 答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改： 因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 \u003c=： int findLeftBound(int[] nums, int target) { // 搜索区间为 [left, right] int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; // if else ... } 因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下： if (nums[mid] \u003c target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u003e target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } 由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界： 因此，最后返回结果时，代码需要检查越界情况： if (left \u003e= nums.length || nums[left] != target) { return -1; } return left; ","date":"2021-12-21","objectID":"/post/binarysearch/:1:0","tags":["算法","Java"],"title":"BinarySearch","uri":"/post/binarysearch/"},{"categories":null,"content":"左边界 最终代码 所以最终的代码完整如下： int findLeftBound(int[] nums, int target) { int left = 0, right = nums.length - 1; // 搜索区间为 [left, right] while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u003e target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } } // 检查出界情况 if (left \u003e= nums.length || nums[left] != target) return -1; return left; } 这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。 寻找右侧边界 类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注： int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } return left - 1; // 注意 } 为什么能找到右侧边界？ if (nums[mid] == target) { left = mid + 1; // 注意这里 当nums[mid] == target时,不是立刻返回mid,而是而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。 答：while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回right - 1好了。 至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个判断条件： if (nums[mid] == target) { left = mid + 1; // 注意这里 这之后，left被更新为left = mid + 1，就是说while循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。见下图： 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1: while (left \u003c right) { // ... } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; 是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 这里改为检查 right 越界的情况，见下图 if (right \u003c 0 || nums[right] != target) return -1; return right; } 当target比所有的元素都小时，right会减小到-1,如下图： 总结 来梳理一下这些细节差异的因果逻辑： 第一个，最基本的二分查找算法： 因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u003c= right) 同时也决定了更新方式是: left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回 第二个，寻找左侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u003c right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界 第三个，寻找右侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u003c right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一 ","date":"2021-12-21","objectID":"/post/binarysearch/:2:0","tags":["算法","Java"],"title":"BinarySearch","uri":"/post/binarysearch/"},{"categories":["python"],"content":"迭代器 可以被next()函数调用并且不断返回下一个值的对象统称为迭代器:Iterator 迭代对象 可以直接作用于for循环的对象，称为可迭代对象 ","date":"2021-12-11","objectID":"/post/ooppython/:0:0","tags":["python","踩坑"],"title":"Python迭代器及常用函数","uri":"/post/ooppython/"},{"categories":["pytorch"],"content":"pytorch View视图 ","date":"2021-12-11","objectID":"/post/numpytensortraps/:0:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"你咋就这么特别呢？ 查看Pytorch官方文档: PyTorch allows a tensor to be a View(视图) of an existing tensor.View(视图) tensor shares the same underlying data with its base tensor. Supporting View(视图) avoids explicit data copy, thus allows us to do fast and memory efficient reshaping, slicing and element-wise operations. 也就是说 视图类型的tensor 本身 不是显式的拷贝了数据，而是使用了它的一个引用。 \u003e\u003e\u003e t = torch.rand(4, 4) \u003e\u003e\u003e b = t.view(2, 8) \u003e\u003e\u003e t.storage().data_ptr() == b.storage().data_ptr() # True 't' 和 'b' 用的是同一块内存 # 但是 b 的 shape 属性是改变了的 \u003e\u003e\u003e t.shape torch.Size([4, 4]) \u003e\u003e\u003e b.shape torch.Size([2, 8]) \u003e\u003e\u003e print(t) tensor([[0.4473, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(b) tensor([[0.4473, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) 由于共用一个地址空间，修改 b 也会同时修改 t \u003e\u003e\u003e b[0][0] = 1 \u003e\u003e\u003e print(b) tensor([[1.0000, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(t) tensor([[1.0000, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) ","date":"2021-12-11","objectID":"/post/numpytensortraps/:1:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"与view()类似的方法 Typically a PyTorch op returns a new tensor as output, e.g. add(). But in case of view ops, outputs are views of input tensors to avoid unncessary data copy. No data movement occurs when creating a view, view tensor just changes the way it interprets the same data. Taking a view of contiguous tensor could potentially produce a non-contiguous tensor. Users should be pay additional attention as contiguity might have implicit performance impact. transpose() is a common example. 可以看到一般来说一个Pytorch操作会返回一个新的tensor作为输出，也就是在一个新内存空间上申请了一个位置，例如add()方法，但是对于view的这种方式，一般输出都会避免不必要的数据深拷贝,仅仅是改变数据的读取顺序。 ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e c = torch.ones_like(b) \u003e\u003e\u003e print(c) tensor([[1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.]]) \u003e\u003e\u003e b = b.add(c) \u003e\u003e\u003e id(b) == id(c) False 需要注意的是：view()和reshape()最大的区别就是当你用view()查看一个连续的tensor的时候会产生不连续的tensor ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e d = torch.tensor([[1, 2],[3, 4]]) \u003e\u003e\u003e t = d.transpose(0,1) # `t`是d的一个view，没有发生地址变化 # 但是view tensor本身是不连续的 \u003e\u003e\u003e t.is_contiguous() False # 如果想要得到的 view tensor(视图张量)也是连续的 \u003e\u003e\u003e c = t.contiguous() 下面列举一些常见的方法也是类似View视图的操作，并且也具有刚才的几个坑 tensor[0, 2:, 1:7:2]返回的也是tensor的一个视图 unflatten() unfold() unsqueeze() squeeze() detach() 当通过索引来访问tensor，Pytorch和Numpy的机制类似，基础的索引就只是返回（views）视图（例如:通过索引赋值都是在原地址上修改），高级的索引操作返回的是数据的深拷贝。 ","date":"2021-12-11","objectID":"/post/numpytensortraps/:2:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"注意区分view() 和 reshape() reshape(), reshape_as() and flatten() 可以返回一个视图 或者 是一个新tensor contiguous() 返回它自身 当且仅当输入tensor已经是连续的了，否则就会返回一个新的拷贝后的连续tensor ","date":"2021-12-11","objectID":"/post/numpytensortraps/:3:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["Deep Learning"],"content":" 在图像复原的过程中，图像上一点点噪声就可能对复原的结果产生较大影响，由于复原算法本身一般都会放大噪声，这时候需要在最优化的问题模型中添加一个正则项约束图像的噪声 （其本身也是loss的一部分）比如图片中相邻像素值之间的差异，可通过降低TV loss来解决 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:0:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"Total Variation Loss (TV loss)初始定义： Rudin等人(Rudin 1990)观察到，受到噪声污染的图像总变分大于无噪声的图像总变分。那么就可以通过最小化图像总变分去抑制噪声，而图片中相邻像素值的差异可以通过降低TV loss来一定程度上缓解。比如对抗checkerboard。 总变分定义为梯度幅值大小的积分 $$ J(u) = \\int_{\\Omega_{u}}|\\nabla_{u}|{dxdy} = \\int_{D_{u}}\\sqrt{u_{x}^{2}+v_{x}^{2}}dxdy $$ 其中： $$ u_{x} = \\frac{\\partial{u}}{\\partial{x}},v_{y} = \\frac{\\partial{v}}{\\partial{y}}, $$ 而图像支持域为 $ D_{u} $ ,限制总变分就会限制噪声 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:1:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"扩展定义 带有阶数的TV loss如下 $$ J^{\\beta} (f)= \\int_{\\Omega}\\Big((\\frac{\\partial{f(u,v)}}{\\partial{u}})^{2}+(\\frac{\\partial{f(u,v)}}{\\partial{v}})^{2}\\Big)^{\\frac{\\beta}{2}}dxdy $$ 但是在图像中，连续的积分就是像素离散域求和 $$ J(x) = \\sum_{i,j}\\big( (x_{[i,j-1]}- x_{[i,j]})^{2}+(x_{[i+1,j]}- x_{[i,j]})^{2}\\big)^{\\frac{\\beta}{2}} $$ 也就是对于每个像素点$x_{[i,j]}$与其**正下方**的像素值差的平方加上其**正左方**的像素值差的平方，然后开$\\frac{\\beta}{2}$次根 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:2:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"3.基于pytorch实现及效果分析 import torch import torch.nn as nn from torch.autograd import Variable class TVLoss(nn.Module): def __init__(self,TVLoss_weight = 1):#设置TVLoss_weight为1 super(TVLoss, self).__init__() self.TVLoss_weight = TVLoss_weight def forward(self, x): #输入tensor为x # x = [batchSize,width,height,channels] batch_size = x.size()[0] h_x = x.size()[2] w_x = x.size()[3] #计算图片高度 count_h = self._tensor_size(x[:,:,1:,:]) #计算图片宽度 count_w = self._tensor_size(x[:,:,:,1:]) h_tv = torch.pow(x[:,:,1:,:]-x[:,:,:h_x-1,:]，2).sum() w_tv = torch.pow((x[:,:,:,1:]-x[:,:,:,:w_x-1]),2).sum() return self.TVLoss_weight*2*( h_tv/count_h + w_tv/count_w) / batch_size def _tensor_size(self, t): return t.size()[1]*t.size()[2]*t.size()[3] def main(): # x = Variable(torch.FloatTensor([[[1,2],[2,3]],[[1,2],[2,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[3,1],[4,3]],[[3,1],[4,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[1,1,1], [2,2,2],[3,3,3]],[[1,1,1], [2,2,2],[3,3,3]]]).view(1, 2, 3, 3), requires_grad=True) x = Variable(torch.FloatTensor([[[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [2, 3, 4], [3, 4, 5]]]).view(1, 2, 3, 3),requires_grad=True) addition = TVLoss() z = addition(x) print x print z.data z.backward() print x.grad if __name__ == '__main__': main() ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:3:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["leetcode","java"],"content":" 题目描述：给定两个可能存在环或者不存在环的单链表head1和head2，找到两个链表的第一个相交节点。 总体思路： 我们希望有一个函数能调用后，告知我们一个链表是否有环，如果有环还能返回第一个入环节点。从而我们通过这个函数findLoopNode找到入环节点，接下来就可以分情况讨论两个链表相交的情况。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:0:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"1. 两链表都无环 即findLoopNode(head1) == findLoopNode(head2) = null。 1.1 如果两个链表相交的话:他们一定从某个节点开始有公共的部分并且公共部分会一直延伸到null节点。 1.2 否则二者一定不相交，从而我们可以通过两者到链表结尾的前一个非null节点判断是否相同判断是否相交。 若相交： 这时候让链表长度长的一方先走差值步数(len(head1) - len(head2)) 然后让链表长度短的与链表长度长的再次同时出发，如果相遇就是第一个相交🍌的节点 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:1:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"2. 两链表中一个有环，一个无环 即findLoopNode(head1) == null || findLoopNode(head2) == null 2.1 这种情况下，无论如何两个链表一定不相交，读者可以在草稿纸上画着试一试，因为题目给定的是单链表，如果相交的话，就说明另一个链表也有环，从而和我们的假设相矛盾。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:2:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"3. 两链表都有环 即findLoopNode(head1) != null \u0026\u0026 findLoopNode(head2) != null 此时分为两种情况： ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"相交 Y字形开始相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ ^ | 6-\u003e3____| |__| 这种比较简单，只需要判断入环节点是否相等，如果相等，那么一定在某个位置开始有入环，比如🌰例子中的5节点，那么此时只需要类似将入环节点视为结尾点（或者当作null），按照两个无环链表相交的情况来寻找他们的相交点即可。 两链表相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9\u003c-3\u003c-6 ^ | |_____| 由于题目说要返回第一个相交节点，可以认为两个链表的其中一个入环节点就是相交节点，将其返回即可，此时要与不相交的情况分开就只有用 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:1","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"不相交 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 3-\u003e0-\u003e6 ^ | |__| ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:2","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"主逻辑实现 public Node findIntersectNode(Node head1, Node head2) { if (head1 == null || head2 == null) { return null; } Node res1 = findLoopNode(head1); Node res2 = findLoopNode(head2); if (res1 == null \u0026\u0026 res2 == null) { //两链表都无环 return intersectPointYStyle(head1, head2, null); } else if (res1 == null || res2 == null) { //其中一个链表有环，另一个无环 return null; } else { if (res1 == res2) { return intersectPointYStyle(head1, head2, res1); } else {//剩下两个情况 1:都有环不相交 2:都有环但是是非Y型相交 res1 = res1.next; while (res1 != res1) { //让res1在环上绕圈 如果碰到 res2 //说明两者相交 if (res1 == res2) { return res1; } res1 = res1.next; } //绕圈中始终没碰到 res2 //说明二者不相交 return null; } } } //这个函数是找Y型相交链表的第一个相交点 public Node intersectPointYStyle(Node head1, Node head2, Node end) { Node cur1 = head1; Node cur2 = head2; int n = 0;//记录两链表的差值 while (cur1 != end) { n++; cur1 = cur1.next; } while (cur2 != end) { n--; cur2 = cur2.next; } //找到先出发的节点 Node first = n \u003e 0 ? head1 : head2; Node second = n \u003e 0 ? head2 : head1; n = Math.abs(n); //让长链表先走差值步 while (n \u003e 0) { first = first.next; n--; } //让两个链表同时走 while (first != second) { first = first.next; second = second.next; } return first; } ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:3","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"findLoopNode()实现： 如果一个单链表有环的话，那么从头节点出发，一定会在某个时刻走到原来的位置，反之就一定会走到null的位置。 因而可以使用快慢指针，如果slow或者fast指针走到了null节点，那么该链表一定不存在环。反之就会出现slow==fast的情况。 入环节点判断 设两指针fast，slow 指向链表头部 head，fast每轮走2步，slow每轮走1步；当fast == slow时，两指针在环中第一次相遇。 下面分析此时fast 与slow走过的步数关系： 设链表共有$a+b$个节点，其中链表头部到链表入口有$a$个节点（不计链表入口节点），链表环有b个节点。 这里需要注意: $a$和$b$是未知数，例如下面例子中链表 $a=4$, $b=2$。 例子: 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 相遇时: 设两指针分别走了 f ，s 步，则有：fast走的步数是slow步数的$2$倍，即 $f = 2s$ 相遇时:fast比slow多走了$n$个环的长度，即:$f = s + nb$;（解析: 双指针都走过 a步，然后在环内绕圈直到重合，重合时fast比 slow多走了环的长度整数倍； 以上两式相减得: $f = 2nb$,$s = nb$，即fast和slow指针分别走了 $2n$，$n$个环的周长（注意：$n$是未知数，不同链表的情况不同）。 目前情况分析： 如果让指针从链表头部一直向前走并统计步数$k$ ，那么所有走到链表入口节点时的步数是：$k = a + nb$ (即：先走$a$步到入口节点，之后每绕$1$圈环(走$b$步) 都会再次到入口节点) 而目前slow指针走过的步数为$nb$步。因此，我们只要想办法让 slow 再走 $a$步停下来，就可以到环的入口。 但是我们不知道$a$的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走$a$步后，两者在入口节点重合。 那么从哪里走到入口节点需要$a$步？答案是链表头部head。 双指针第二次相遇: slow指针位置不变 ，将 fast 指针重新指向链表头部节点;slow和 fast 同时每轮向前走1步； TIPS：此时 $f = 0$，$s = nb$； 当 fast 指针走到$f = a$步时,slow指针走到步$s = a+nb$，此时两指针重合，并同时指向链表环入口。 第二次相遇后，返回slow指针指向的节点即可。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:4","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"实现：（使用快慢指针） public findLoopNode(Node head) { if (head == null || head.next == null || head.next.next == null) { //由于我们希望快指针一开始就运动到比slow的下个位置 return null; } Node slow = head.next; Node fast = head.next.next; while (slow != fast) { if (fast.next == null || fast.next.next == null) {//一旦快指针走到终点，说明无环 return null; } slow = slow.next; fast = fast.next.next; } //相遇了,将fast指向slow fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:5","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":null,"content":"推荐系统的实验方法分类 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:0:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"1.离线实验 通过日志系统，获取用户行为数据，按照一定格式生产出一个标准的数据集 将数据集划分为训练集和测试集 在训练集上训练用户兴趣模型，并在测试集上进行预测 通过事先定义的离线指标评价算法在测试集上的预测结果 优点： 无需对实际系统有控制权（换言之，无需对真实有用户的系统来测试） 无需用户参与（仅仅根据用户历史数据） 速度快，可以测试大量算法 缺点： 无法真正计算商业上关注的指标：点击率，转化率（而且找到一个和商业指标相关的离线指标也很困难） 离线指标和实际商业指标有差距 （比如：预测准确率和用户的满意度之间就存在很大的差别） 总结 最好的办法就是将离线算法直接上线测试，但在对算法会不会降低用户满意度没有把握的情况下，上线测试有很高的风险，因此上线前一般需要进行一次用户调查 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:1:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"2.用户调查 1.调查真实用户，让他们在真实的推荐系统上完成一些任务 2.观察和记录用户行为，并且让用户回答一些相关的问题 3.通过分析用户调查的行为和答案，了解测试系统性能 优点： 体现更多用户的主观感受指标，相对在线实验风险很低，出错后容易弥补 可以展现出真实的客户需求，及满意度 缺点： 招募测试用户代价很高，很难组织大规模的测试用户，使得测试结果的统计意义不足 设计双盲实验十分困难，用户在实验环境下的行为和真实场景会呈现出不同 总结： 需要选取与真实用户身份分布一致的测试用户数量，比如年龄/活跃度，此外需要保证用户的回答可靠，不要让实验者和用户提前知道测试的目的，以免回答受到影响 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:2:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"3.在线实验 将推荐系统上线做AB测试，将它和旧的算法进行比较 优点： 缺点： 总结： ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:3:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":["leetcode","java"],"content":" 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –\u003e y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。你的代码只接受原链表的头节点head作为传入参数。 链表节点定义如下： // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1: 生成clone节点copyNode，用HashMap来存储\u003c原始Node,拷贝Node\u003e这样的键值对，存储起来 再去设置copyNode的random和next指针。 利用这个键值对的性质，每个拷贝Node的random指针需要指向的位置：就是原始Node的random指针指向那个Node的拷贝，而要找到这个值，就是利用hashmap.get(Node.random) 比如：1 -\u003e 2,1' -\u003e 2' 由于(1，1‘)构成了键值对，(2，2’)也构成了键值对，所以1‘的random需要指向2的拷贝2’ public class Solution1 { HashMap\u003cNode, Node\u003e map = new HashMap\u003c\u003e(); /** ** 思路1 */ public Node copyRandomList1(Node head) { Node cur = head; //利用 key 存放原链表节点,val 存放copyNode while (cur != null) { Node copyCur = new Node(cur.val); map.put(cur,copyCur); cur = cur.next; } cur = head; //对应设置好 next 和 random指针 while (cur != null) { Node copyCur = map.get(cur); //能这样设置的原因，就是提前将 (cur, copyCur)放入， //而每个cur能映射到它对应的copyCur copyCur.next = map.get(cur.next); copyCur.random = map.get(cur.random); cur = cur.next; } return map.get(head); } } 思路2: 对应每个原始链表的当前节点Cur生成Copy节点，将Copy节点放在原始链表的当前节点Cur的下一个位置nxt 再次遍历这个由新老节点构成的链表，设置Copy节点的random指针，它对应的random指向了Cur的random所指向的节点的下一个节点 最后我们只需要将原始链表从新构成的链表分离出来就可以了，返回的答案也要是新的拷贝链表的头节点 举个例子来说一个新构成的链表如下： 1 -\u003e 1' -\u003e 2 -\u003e 2' 假定原始链表中：2的random指向了1，那么在设置2‘的random时只需要将其指向1的next就可以了 //更省内存的方法 /** ** 思路2 */ public class Solution2 { public Node copyRandomList2(Node head) { if (head == null) { return null; } Node cur = head; Node nxt = null;//next指向原始链表中当前节点cur的下一个节点 Node copyCur = null; while (cur != null) { // 1 -\u003e 2 // cur nxt nxt = cur.next; // 1‘ 1 -\u003e 2 // copyCur cur nxt copyCur = new Node(cur.val); // 1 -\u003e 1‘ 2 // cur copyCur nxt cur.next = copyCur; // 1 -\u003e 1‘ -\u003e 2 // cur copyCur nxt copyCur.next = nxt; // 1 -\u003e 1' -\u003e 2 // cur cur = nxt; } //reset 回起点 cur = head; // 设置rand指针 while (cur != null) { // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur nxt copyCur = cur.next; nxt = cur.next.next; //一定要判断 cur.rand是否为null copyCur.random = cur.random != null ? cur.random.next : null; //移动copyCur和cur // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur cur = nxt; } //split 断开两个链表的连接 //先记下最终结果的头节点 Node res = head.next; cur = head; while (cur != null) { copyCur = cur.next; nxt = cur.next.next; // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur nxt // 1' -\u003e 2' // 1 -\u003e 2 copyCur.next = nxt != null ? nxt.next : null; cur.next = nxt; cur = nxt; } return res; } } ","date":"2021-11-24","objectID":"/post/copylistwithrand/:0:0","tags":["LinkedList"],"title":"leetcode-Copy Linkedlist with Random pointer","uri":"/post/copylistwithrand/"},{"categories":["java基础"],"content":"为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了 public static testStack() { Deque\u003cInteger\u003e stack = new Deque\u003cInteger\u003e(); stack.push(1); stack.push(3); stack.push(4); stack.peek(); // 4 stack.pop(); // 4 stack.pop(); // 3 stack.pop(); // 1 } Deque接口的stack主要调用有三个方法: push() peek() pop() 不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰 ","date":"2021-11-24","objectID":"/post/stack/:0:0","tags":["Java"],"title":"java-Stack","uri":"/post/stack/"},{"categories":["leetcode","java"],"content":"Q1: 判断一个链表 是否属于回文结构 // example1 input: 1 -\u003e 2 -\u003e 23 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example2 input: 1 -\u003e 2 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example3 input: 1 -\u003e 2 -\u003e 23 -\u003e 3 -\u003e 1 output: false ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:0:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"思路一: ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:1:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"利用一个stack来实现 Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(n)$ 将链表以中点部分为界的后半部分逐个压栈，如果遇到中点就停止入栈。 然后从中点位置开始依次弹出栈元素，同时重头开始遍历链表,将链表中的元素与栈元素比较，如果不相同返回false否则返回true 注意奇/偶长度的链表情况下：slow指针停下的位置，以及stack是否应该添加当前位置的值 public boolean ifPalindrome (Node head) { if (head == null || head.next == null) { return true; } Deque\u003cInteger\u003e stack = new ArrayDeque\u003cInteger\u003e(); //先找到中点 Node midPoint = findMid(head); Node cur = head; while (cur != midPoint.next) { stack.push(cur.val); cur = cur.next; } return true; } //奇偶条件下 slow指针的位置 // 1-\u003e2-\u003e2-\u003e1-\u003enull // s s // f f // 1-\u003e2-\u003e1-\u003enull // s s // f f private Node findMid(Node head) { if(head == null || head.next) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:1:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"思路二: ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:2:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":" Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(1)$ 用快慢指针法找到链表的中点，然后将链表的后半段进行反转，然后cur1从头节点开始遍历，cur2从中点开始遍历，如果cur1指针所指向的值不等于cur2指针的值，那么就返回false，否则返回true，最好在返回时还能够将原链表复原 public Node ifPalindromeList(Node head) { if(head == null || head.next == null) { return true; } Node mid = findMid(head); Node head2 = reverseList(mid.next); //注意要断开 mid 和 mid.next 之间的联系 mid.next = null; Node cur2 = head2; Node cur1 = head; //就算是奇数个节点也没有问题 //因为奇数个节点的时候 其中cur2会走到null //而cur1会走到链表中点的位置 while (cur1 != null \u0026\u0026 cur2 != null) { if (cur1.val != cur2.val) { return false; } cur1 = cur1.next; cur2 = cur2.next; } head2 = reverseList(head2); mid.next = head2; return true; } private Node findMid(Node head) { if(head == null || head.next == null) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } private Node reverseList(Node head) { if (head == null || head.next == null) { return head; } Node pre = null; Node cur = head; Node nxt = head.next; // 1 -\u003e 2 -\u003e null // cur nxt while (nxt != null) { cur.next = pre; pre = cur; cur = nxt; nxt = nxt.next; } cur.next = pre; return cur; } ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:2:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":null,"content":"Rage, rage against the dying of the light! Old days shall fade away. 致力于研究美食，发掘自身潜能的一枚 AI beginner. 撰写博客只是为了开心，更多的是记录自己的学习过程 更多关于我的介绍请看简历/Resume ","date":"2021-11-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Development","Hugo"],"content":"GitHub设置 首先创建个人网站的一个repo： 注意命名规则:一定是你的用户名.github.io比如sophshep.github.io 详见下面这个图片: 建议：为了后续的开发也可以再创建一个仓库 Hugo安装及配置 首先安装 Hugo，在不同系统上安装都很简单，我使用的是 Mac ，使用 Homebrew 可以安装 Hugo： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"下载Hugo brew install hugo 创建一个基础网站 当你在当前路径下的终端内输入 hugo new site mySite 就会自动创建一个mySite的根文件夹┑(￣Д ￣)┍ ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"Hugo网站文件夹目录 顺带提一嘴这个文件结构，对后续写文章比较重要 mySite |–layout |–content |–static |–data |–themes |–config.toml |–archetypes content - 内容文件夹开发中的内容大多数都保存在这里 也就是markdown文件存储的位置 你post的文章的md后缀文件也会出现在这里 static - 静态文件夹一些静态的文件，比如说嵌入的图片,图片位置 themes - 主题文件夹 config.toml - 配置文件 基础的一些网站设置，比如网站的名字 archetypes - 样例文件夹 可以透过 hugo new \u003ccontentdir/contentfile.md\u003e来创建新的内容 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"选择并安装一个合适的主题并进行初始配置 挑选好一个theme之后load到你的本地 git submodule add \u003ctheme-github-url\u003e \u003ctarget-directory\u003e 下面我们要告诉Hugo我们所将使用的主题 echo 'theme = \"\u003ctheme-name\u003e\"' \u003e\u003e config.toml 我这里用的是： echo 'theme = \"even\"'\u003e\u003e config.toml 当然你也可以直接打开编辑器修改toml.config文件 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:1:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地测试一下你的新网站及博文 输入下面的命令后会自动发布一篇测试文章： hugo new post/testpage.md 新的testpage.md页面会存在content/post/testpage.md中，而content文件夹是Hugo创建静态网页的内容（你所写的博客基本都在这里） --- title: \"Testpage\" date: 2020-08-27T13:43:09-06:00 draft: true --- 打开archetypes/default.md可以发现，上面Testpage.md的内容是依赖下面的自动生成的，而draft的设置为true表明现在的Testpage处于草稿阶段，修改为false即可 --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true --- 需要注意的是： 第一个---到第二个--- 符号之间是front matter（Hugo的专用术语）类似于HTML中的\u003cmeta\u003e标签是用来定义页面头部的一些信息（渲染标题和其他的元数据）的，而在第二个--- 符号之后就是你的正文部分 或者说相当于HTML的body 关于config.toml的一些设置偏好 baseurl: 就是你想发布的网站：如https://.github.io title：标题，显示在每个页面的左上，一般都是自己的id languageCode：页面语言，指定编码格式，比如en-us/en-gb/cn表示英语-美国/英语-英国 paginate：在主页上显示多少条博客内容 [markup]:这一部部分显示使用哪一种markup/down语法，它一般不会渲染HTML标签否则可能产生安全问题，但如果你想要强制使用的话：设置unsafe = true [params] - 基础的参数设置 header_image - 默认的所有页面的背景图片，并且固定作为home页面和about页面的图片 title - 文章标题，显示在每个页面 slogan - 子标题 sidebar_about_description, sidebar_avatar, \u0026 about_me：侧边栏介绍，侧边栏可以用于简单的自我介绍，提供一些个人简介之类的，而将about_me设置为true就可以实现了 featured_tags： 是用来指定有多少个tags你想在页面中显示 feature_condition_size：指定每篇文章最少要给出多少个tag在tag云中 image_404 \u0026 title_404 - 当文章找不到，显示的404图片 omit_categories - 是否要忽略导航栏分类功能 [[params.additional_menus]] - 提供在导航栏中提供额外的菜单，比如About页面 [params.social] - 社交账户设置 baseurl = \"https://fakeRichardWH.github.io\" title = \"fakeRichardWH\" theme = \"even\" languageCode = \"en-us\" paginate = 5000 #frontpage pagination [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [params] header_image = \"images/main_go_wideandtall_darklayer.jpeg\" title = \"Software Engineering\" slogan = \"$ grep -rni \\\"The how's and why's\\\" .\" SEOTitle = \"fakeRichardWH Blog\" keyword = \"fakeRichardWH, TestTools, MachineLEARNING, JAVA, SpringBoot\" # Sidebar settings sidebar_about_description = \"Husband, Skier, Cyclist, and, oh yeah, Software Developer\" sidebar_avatar = \"images/MeAtUS.jpeg\" about_me = true featured_tags = true featured_condition_size = 2 # 当有多少条post时可以实现按标签索引 (大于) image_404 = \"images/404-bg.jpg\" title_404 = \"We couldn't find what you were looking for...\" omit_categories = false [[params.addtional_menus]] title = \"ABOUT\" href = \"/top/about/\" [params.social] rss = true email = \"testMe@gmail.com\" linkedin = \"https://www.linkedin.com/in/richard-youngkin-0749763\" github = \"https://github.com/youngkin\" stackoverflow = \"https://stackoverflow.com/users/2646870/rich\" reddit = \"https://www.reddit.com/user/elevation5280\" 常用命令（Hugo及Git） ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地服务器启动 下面这个代码会启动一个本地的Hugo Web服务器 hugo server -D 输入后会显示： Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 我们之后可以用浏览器打开该网址看看写的文章： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":" 一个完整的工作流 （写博文/更改博文） 1.创建一个文档hugo new post/my-xxx-post.md，用markdown语法 （推荐用VScode + Markdown的扩展，可以本地及时查看博文变动） 2.本地测试文档，删除一些不必要的文件 3.使用hugo命令 4.使用git命令完成相应文章的上传/更新 #写完博文之后 hugo cd public git add . git commit -m \"blog added\" git push -u origin master #一般都是在master分支上去操作 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"总结一下Hugo命令 hugo -D #搭建静态页面 输出到 ./public 目录中 如果不另外指定的话 hugo server # 一般是用于本地web服务器校对 hugo #部署时使用 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:3:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"content的目录结构 用下面一个样例结构来进行说明 content/ ├── about │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ │ ├── image1.jpg │ │ ├── image2.png │ │ └── index.md │ └── my-other-post │ └── index.md │ └── another-section ├── .. └── not-a-leaf-bundle ├── .. └── another-leaf-bundle └── index.md 上面这个是一个典型的四级目录包 about: 建立在root级别之下，其中只有一个index.md文件 my-post: image1: image2: my-other-post: ","date":"2021-11-03","objectID":"/post/hugocreatesite/:4:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"}]