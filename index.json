[{"categories":["pytorch"],"content":"pytorch View视图 ","date":"2021-12-11","objectID":"/post/numpytensortraps/:0:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"你咋就这么特别呢？ 查看Pytorch官方文档: PyTorch allows a tensor to be a View(视图) of an existing tensor.View(视图) tensor shares the same underlying data with its base tensor. Supporting View(视图) avoids explicit data copy, thus allows us to do fast and memory efficient reshaping, slicing and element-wise operations. 也就是说 视图类型的tensor 本身 不是显式的拷贝了数据，而是使用了它的一个引用。 \u003e\u003e\u003e t = torch.rand(4, 4) \u003e\u003e\u003e b = t.view(2, 8) \u003e\u003e\u003e t.storage().data_ptr() == b.storage().data_ptr() # True 't' 和 'b' 用的是同一块内存 # 但是 b 的 shape 属性是改变了的 \u003e\u003e\u003e t.shape torch.Size([4, 4]) \u003e\u003e\u003e b.shape torch.Size([2, 8]) \u003e\u003e\u003e print(t) tensor([[0.4473, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(b) tensor([[0.4473, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) 由于共用一个地址空间，修改 b 也会同时修改 t \u003e\u003e\u003e b[0][0] = 1 \u003e\u003e\u003e print(b) tensor([[1.0000, 0.3079, 0.5223, 0.2924, 0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673, 0.0829, 0.1356, 0.9617, 0.2030]]) \u003e\u003e\u003e print(t) tensor([[1.0000, 0.3079, 0.5223, 0.2924], [0.9936, 0.9032, 0.7414, 0.6115], [0.0904, 0.6525, 0.6720, 0.8673], [0.0829, 0.1356, 0.9617, 0.2030]]) ","date":"2021-12-11","objectID":"/post/numpytensortraps/:1:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"与view()类似的方法 Typically a PyTorch op returns a new tensor as output, e.g. add(). But in case of view ops, outputs are views of input tensors to avoid unncessary data copy. No data movement occurs when creating a view, view tensor just changes the way it interprets the same data. Taking a view of contiguous tensor could potentially produce a non-contiguous tensor. Users should be pay additional attention as contiguity might have implicit performance impact. transpose() is a common example. 可以看到一般来说一个Pytorch操作会返回一个新的tensor作为输出，也就是在一个新内存空间上申请了一个位置，例如add()方法，但是对于view的这种方式，一般输出都会避免不必要的数据深拷贝,仅仅是改变数据的读取顺序。 ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e c = torch.ones_like(b) \u003e\u003e\u003e print(c) tensor([[1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.]]) \u003e\u003e\u003e b = b.add(c) \u003e\u003e\u003e id(b) == id(c) False 需要注意的是：view()和reshape()最大的区别就是当你用view()查看一个连续的tensor的时候会产生不连续的tensor ## 下面的代码中的变量与前面的一致 \u003e\u003e\u003e d = torch.tensor([[1, 2],[3, 4]]) \u003e\u003e\u003e t = d.transpose(0,1) # `t`是d的一个view，没有发生地址变化 # 但是view tensor本身是不连续的 \u003e\u003e\u003e t.is_contiguous() False # 如果想要得到的 view tensor(视图张量)也是连续的 \u003e\u003e\u003e c = t.contiguous() 下面列举一些常见的方法也是类似View视图的操作，并且也具有刚才的几个坑 tensor[0, 2:, 1:7:2]返回的也是tensor的一个视图 unflatten() unfold() unsqueeze() squeeze() detach() 当通过索引来访问tensor，Pytorch和Numpy的机制类似，基础的索引就只是返回（views）视图（例如:通过索引赋值都是在原地址上修改），高级的索引操作返回的是数据的深拷贝。 ","date":"2021-12-11","objectID":"/post/numpytensortraps/:2:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["pytorch"],"content":"注意区分view() 和 reshape() reshape(), reshape_as() and flatten() 可以返回一个视图 或者 是一个新tensor contiguous() 返回它自身 当且仅当输入tensor已经是连续的了，否则就会返回一个新的拷贝后的连续tensor ","date":"2021-12-11","objectID":"/post/numpytensortraps/:3:0","tags":["pytorch","踩坑"],"title":"Pytorch中view方法的坑","uri":"/post/numpytensortraps/"},{"categories":["Deep Learning"],"content":" 在图像复原的过程中，图像上一点点噪声就可能对复原的结果产生较大影响，由于复原算法本身一般都会放大噪声，这时候需要在最优化的问题模型中添加一个正则项约束图像的噪声 （其本身也是loss的一部分）比如图片中相邻像素值之间的差异，可通过降低TV loss来解决 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:0:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"Total Variation Loss (TV loss)初始定义： Rudin等人(Rudin 1990)观察到，受到噪声污染的图像总变分大于无噪声的图像总变分。那么就可以通过最小化图像总变分去抑制噪声，而图片中相邻像素值的差异可以通过降低TV loss来一定程度上缓解。比如对抗checkerboard。 总变分定义为梯度幅值大小的积分 $$ J(u) = \\int_{\\Omega_{u}}|\\nabla_{u}|{dxdy} = \\int_{D_{u}}\\sqrt{u_{x}^{2}+v_{x}^{2}}dxdy $$ 其中： $$ u_{x} = \\frac{\\partial{u}}{\\partial{x}},v_{y} = \\frac{\\partial{v}}{\\partial{y}}, $$ 而图像支持域为 $ D_{u} $ ,限制总变分就会限制噪声 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:1:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"扩展定义 带有阶数的TV loss如下 $$ J^{\\beta} (f)= \\int_{\\Omega}\\Big((\\frac{\\partial{f(u,v)}}{\\partial{u}})^{2}+(\\frac{\\partial{f(u,v)}}{\\partial{v}})^{2}\\Big)^{\\frac{\\beta}{2}}dxdy $$ 但是在图像中，连续的积分就是像素离散域求和 $$ J(x) = \\sum_{i,j}\\big( (x_{[i,j-1]}- x_{[i,j]})^{2}+(x_{[i+1,j]}- x_{[i,j]})^{2}\\big)^{\\frac{\\beta}{2}} $$ 也就是对于每个像素点$x_{[i,j]}$与其**正下方**的像素值差的平方加上其**正左方**的像素值差的平方，然后开$\\frac{\\beta}{2}$次根 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:2:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"3.基于pytorch实现及效果分析 import torch import torch.nn as nn from torch.autograd import Variable class TVLoss(nn.Module): def __init__(self,TVLoss_weight = 1):#设置TVLoss_weight为1 super(TVLoss, self).__init__() self.TVLoss_weight = TVLoss_weight def forward(self, x): #输入tensor为x # x = [batchSize,width,height,channels] batch_size = x.size()[0] h_x = x.size()[2] w_x = x.size()[3] #计算图片高度 count_h = self._tensor_size(x[:,:,1:,:]) #计算图片宽度 count_w = self._tensor_size(x[:,:,:,1:]) h_tv = torch.pow(x[:,:,1:,:]-x[:,:,:h_x-1,:]，2).sum() w_tv = torch.pow((x[:,:,:,1:]-x[:,:,:,:w_x-1]),2).sum() return self.TVLoss_weight*2*( h_tv/count_h + w_tv/count_w) / batch_size def _tensor_size(self, t): return t.size()[1]*t.size()[2]*t.size()[3] def main(): # x = Variable(torch.FloatTensor([[[1,2],[2,3]],[[1,2],[2,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[3,1],[4,3]],[[3,1],[4,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[1,1,1], [2,2,2],[3,3,3]],[[1,1,1], [2,2,2],[3,3,3]]]).view(1, 2, 3, 3), requires_grad=True) x = Variable(torch.FloatTensor([[[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [2, 3, 4], [3, 4, 5]]]).view(1, 2, 3, 3),requires_grad=True) addition = TVLoss() z = addition(x) print x print z.data z.backward() print x.grad if __name__ == '__main__': main() ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:3:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["leetcode","java"],"content":" 题目描述：给定两个可能存在环或者不存在环的单链表head1和head2，找到两个链表的第一个相交节点。 总体思路： 我们希望有一个函数能调用后，告知我们一个链表是否有环，如果有环还能返回第一个入环节点。从而我们通过这个函数findLoopNode找到入环节点，接下来就可以分情况讨论两个链表相交的情况。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:0:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"1. 两链表都无环 即findLoopNode(head1) == findLoopNode(head2) = null。 1.1 如果两个链表相交的话:他们一定从某个节点开始有公共的部分并且公共部分会一直延伸到null节点。 1.2 否则二者一定不相交，从而我们可以通过两者到链表结尾的前一个非null节点判断是否相同判断是否相交。 若相交： 这时候让链表长度长的一方先走差值步数(len(head1) - len(head2)) 然后让链表长度短的与链表长度长的再次同时出发，如果相遇就是第一个相交🍌的节点 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:1:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"2. 两链表中一个有环，一个无环 即findLoopNode(head1) == null || findLoopNode(head2) == null 2.1 这种情况下，无论如何两个链表一定不相交，读者可以在草稿纸上画着试一试，因为题目给定的是单链表，如果相交的话，就说明另一个链表也有环，从而和我们的假设相矛盾。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:2:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"3. 两链表都有环 即findLoopNode(head1) != null \u0026\u0026 findLoopNode(head2) != null 此时分为两种情况： ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:0","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"相交 Y字形开始相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ ^ | 6-\u003e3____| |__| 这种比较简单，只需要判断入环节点是否相等，如果相等，那么一定在某个位置开始有入环，比如🌰例子中的5节点，那么此时只需要类似将入环节点视为结尾点（或者当作null），按照两个无环链表相交的情况来寻找他们的相交点即可。 两链表相交后进入同一个环 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9\u003c-3\u003c-6 ^ | |_____| 由于题目说要返回第一个相交节点，可以认为两个链表的其中一个入环节点就是相交节点，将其返回即可，此时要与不相交的情况分开就只有用 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:1","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"不相交 例子🌰： 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 3-\u003e0-\u003e6 ^ | |__| ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:2","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"主逻辑实现 public Node findIntersectNode(Node head1, Node head2) { if (head1 == null || head2 == null) { return null; } Node res1 = findLoopNode(head1); Node res2 = findLoopNode(head2); if (res1 == null \u0026\u0026 res2 == null) { //两链表都无环 return intersectPointYStyle(head1, head2, null); } else if (res1 == null || res2 == null) { //其中一个链表有环，另一个无环 return null; } else { if (res1 == res2) { return intersectPointYStyle(head1, head2, res1); } else {//剩下两个情况 1:都有环不相交 2:都有环但是是非Y型相交 res1 = res1.next; while (res1 != res1) { //让res1在环上绕圈 如果碰到 res2 //说明两者相交 if (res1 == res2) { return res1; } res1 = res1.next; } //绕圈中始终没碰到 res2 //说明二者不相交 return null; } } } //这个函数是找Y型相交链表的第一个相交点 public Node intersectPointYStyle(Node head1, Node head2, Node end) { Node cur1 = head1; Node cur2 = head2; int n = 0;//记录两链表的差值 while (cur1 != end) { n++; cur1 = cur1.next; } while (cur2 != end) { n--; cur2 = cur2.next; } //找到先出发的节点 Node first = n \u003e 0 ? head1 : head2; Node second = n \u003e 0 ? head2 : head1; n = Math.abs(n); //让长链表先走差值步 while (n \u003e 0) { first = first.next; n--; } //让两个链表同时走 while (first != second) { first = first.next; second = second.next; } return first; } ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:3","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"findLoopNode()实现： 如果一个单链表有环的话，那么从头节点出发，一定会在某个时刻走到原来的位置，反之就一定会走到null的位置。 因而可以使用快慢指针，如果slow或者fast指针走到了null节点，那么该链表一定不存在环。反之就会出现slow==fast的情况。 入环节点判断 设两指针fast，slow 指向链表头部 head，fast每轮走2步，slow每轮走1步；当fast == slow时，两指针在环中第一次相遇。 下面分析此时fast 与slow走过的步数关系： 设链表共有$a+b$个节点，其中链表头部到链表入口有$a$个节点（不计链表入口节点），链表环有b个节点。 这里需要注意: $a$和$b$是未知数，例如下面例子中链表 $a=4$, $b=2$。 例子: 1-\u003e2-\u003e4-\u003e5-\u003e7-\u003e8-\u003e9 ^ | |_____| 相遇时: 设两指针分别走了 f ，s 步，则有：fast走的步数是slow步数的$2$倍，即 $f = 2s$ 相遇时:fast比slow多走了$n$个环的长度，即:$f = s + nb$;（解析: 双指针都走过 a步，然后在环内绕圈直到重合，重合时fast比 slow多走了环的长度整数倍； 以上两式相减得: $f = 2nb$,$s = nb$，即fast和slow指针分别走了 $2n$，$n$个环的周长（注意：$n$是未知数，不同链表的情况不同）。 目前情况分析： 如果让指针从链表头部一直向前走并统计步数$k$ ，那么所有走到链表入口节点时的步数是：$k = a + nb$ (即：先走$a$步到入口节点，之后每绕$1$圈环(走$b$步) 都会再次到入口节点) 而目前slow指针走过的步数为$nb$步。因此，我们只要想办法让 slow 再走 $a$步停下来，就可以到环的入口。 但是我们不知道$a$的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走$a$步后，两者在入口节点重合。 那么从哪里走到入口节点需要$a$步？答案是链表头部head。 双指针第二次相遇: slow指针位置不变 ，将 fast 指针重新指向链表头部节点;slow和 fast 同时每轮向前走1步； TIPS：此时 $f = 0$，$s = nb$； 当 fast 指针走到$f = a$步时,slow指针走到步$s = a+nb$，此时两指针重合，并同时指向链表环入口。 第二次相遇后，返回slow指针指向的节点即可。 ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:4","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":["leetcode","java"],"content":"实现：（使用快慢指针） public findLoopNode(Node head) { if (head == null || head.next == null || head.next.next == null) { //由于我们希望快指针一开始就运动到比slow的下个位置 return null; } Node slow = head.next; Node fast = head.next.next; while (slow != fast) { if (fast.next == null || fast.next.next == null) {//一旦快指针走到终点，说明无环 return null; } slow = slow.next; fast = fast.next.next; } //相遇了,将fast指向slow fast = head; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } ","date":"2021-12-04","objectID":"/post/findloopnodeinlinkelist/:3:5","tags":["double pointer method","LinkedList"],"title":"leetcode-寻找入环节点","uri":"/post/findloopnodeinlinkelist/"},{"categories":null,"content":"推荐系统的实验方法分类 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:0:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"1.离线实验 通过日志系统，获取用户行为数据，按照一定格式生产出一个标准的数据集 将数据集划分为训练集和测试集 在训练集上训练用户兴趣模型，并在测试集上进行预测 通过事先定义的离线指标评价算法在测试集上的预测结果 优点： 无需对实际系统有控制权（换言之，无需对真实有用户的系统来测试） 无需用户参与（仅仅根据用户历史数据） 速度快，可以测试大量算法 缺点： 无法真正计算商业上关注的指标：点击率，转化率（而且找到一个和商业指标相关的离线指标也很困难） 离线指标和实际商业指标有差距 （比如：预测准确率和用户的满意度之间就存在很大的差别） 总结 最好的办法就是将离线算法直接上线测试，但在对算法会不会降低用户满意度没有把握的情况下，上线测试有很高的风险，因此上线前一般需要进行一次用户调查 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:1:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"2.用户调查 1.调查真实用户，让他们在真实的推荐系统上完成一些任务 2.观察和记录用户行为，并且让用户回答一些相关的问题 3.通过分析用户调查的行为和答案，了解测试系统性能 优点： 体现更多用户的主观感受指标，相对在线实验风险很低，出错后容易弥补 可以展现出真实的客户需求，及满意度 缺点： 招募测试用户代价很高，很难组织大规模的测试用户，使得测试结果的统计意义不足 设计双盲实验十分困难，用户在实验环境下的行为和真实场景会呈现出不同 总结： 需要选取与真实用户身份分布一致的测试用户数量，比如年龄/活跃度，此外需要保证用户的回答可靠，不要让实验者和用户提前知道测试的目的，以免回答受到影响 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:2:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"3.在线实验 将推荐系统上线做AB测试，将它和旧的算法进行比较 优点： 缺点： 总结： ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:3:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":["leetcode","java"],"content":" 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –\u003e y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。你的代码只接受原链表的头节点head作为传入参数。 链表节点定义如下： // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1: 生成clone节点copyNode，用HashMap来存储\u003c原始Node,拷贝Node\u003e这样的键值对，存储起来 再去设置copyNode的random和next指针。 利用这个键值对的性质，每个拷贝Node的random指针需要指向的位置：就是原始Node的random指针指向那个Node的拷贝，而要找到这个值，就是利用hashmap.get(Node.random) 比如：1 -\u003e 2,1' -\u003e 2' 由于(1，1‘)构成了键值对，(2，2’)也构成了键值对，所以1‘的random需要指向2的拷贝2’ public class Solution1 { HashMap\u003cNode, Node\u003e map = new HashMap\u003c\u003e(); /** ** 思路1 */ public Node copyRandomList1(Node head) { Node cur = head; //利用 key 存放原链表节点,val 存放copyNode while (cur != null) { Node copyCur = new Node(cur.val); map.put(cur,copyCur); cur = cur.next; } cur = head; //对应设置好 next 和 random指针 while (cur != null) { Node copyCur = map.get(cur); //能这样设置的原因，就是提前将 (cur, copyCur)放入， //而每个cur能映射到它对应的copyCur copyCur.next = map.get(cur.next); copyCur.random = map.get(cur.random); cur = cur.next; } return map.get(head); } } 思路2: 对应每个原始链表的当前节点Cur生成Copy节点，将Copy节点放在原始链表的当前节点Cur的下一个位置nxt 再次遍历这个由新老节点构成的链表，设置Copy节点的random指针，它对应的random指向了Cur的random所指向的节点的下一个节点 最后我们只需要将原始链表从新构成的链表分离出来就可以了，返回的答案也要是新的拷贝链表的头节点 举个例子来说一个新构成的链表如下： 1 -\u003e 1' -\u003e 2 -\u003e 2' 假定原始链表中：2的random指向了1，那么在设置2‘的random时只需要将其指向1的next就可以了 //更省内存的方法 /** ** 思路2 */ public class Solution2 { public Node copyRandomList2(Node head) { if (head == null) { return null; } Node cur = head; Node nxt = null;//next指向原始链表中当前节点cur的下一个节点 Node copyCur = null; while (cur != null) { // 1 -\u003e 2 // cur nxt nxt = cur.next; // 1‘ 1 -\u003e 2 // copyCur cur nxt copyCur = new Node(cur.val); // 1 -\u003e 1‘ 2 // cur copyCur nxt cur.next = copyCur; // 1 -\u003e 1‘ -\u003e 2 // cur copyCur nxt copyCur.next = nxt; // 1 -\u003e 1' -\u003e 2 // cur cur = nxt; } //reset 回起点 cur = head; // 设置rand指针 while (cur != null) { // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur nxt copyCur = cur.next; nxt = cur.next.next; //一定要判断 cur.rand是否为null copyCur.random = cur.random != null ? cur.random.next : null; //移动copyCur和cur // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur cur = nxt; } //split 断开两个链表的连接 //先记下最终结果的头节点 Node res = head.next; cur = head; while (cur != null) { copyCur = cur.next; nxt = cur.next.next; // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur nxt // 1' -\u003e 2' // 1 -\u003e 2 copyCur.next = nxt != null ? nxt.next : null; cur.next = nxt; cur = nxt; } return res; } } ","date":"2021-11-24","objectID":"/post/copylistwithrand/:0:0","tags":["LinkedList"],"title":"leetcode-Copy Linkedlist with Random pointer","uri":"/post/copylistwithrand/"},{"categories":["java基础"],"content":"为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了 public static testStack() { Deque\u003cInteger\u003e stack = new Deque\u003cInteger\u003e(); stack.push(1); stack.push(3); stack.push(4); stack.peek(); // 4 stack.pop(); // 4 stack.pop(); // 3 stack.pop(); // 1 } Deque接口的stack主要调用有三个方法: push() peek() pop() 不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰 ","date":"2021-11-24","objectID":"/post/stack/:0:0","tags":["Java"],"title":"java-Stack","uri":"/post/stack/"},{"categories":["leetcode","java"],"content":"Q1: 判断一个链表 是否属于回文结构 // example1 input: 1 -\u003e 2 -\u003e 23 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example2 input: 1 -\u003e 2 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example3 input: 1 -\u003e 2 -\u003e 23 -\u003e 3 -\u003e 1 output: false ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:0:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"思路一: ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:1:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"利用一个stack来实现 Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(n)$ 将链表以中点部分为界的后半部分逐个压栈，如果遇到中点就停止入栈。 然后从中点位置开始依次弹出栈元素，同时重头开始遍历链表,将链表中的元素与栈元素比较，如果不相同返回false否则返回true 注意奇/偶长度的链表情况下：slow指针停下的位置，以及stack是否应该添加当前位置的值 public boolean ifPalindrome (Node head) { if (head == null || head.next == null) { return true; } Deque\u003cInteger\u003e stack = new ArrayDeque\u003cInteger\u003e(); //先找到中点 Node midPoint = findMid(head); Node cur = head; while (cur != midPoint.next) { stack.push(cur.val); cur = cur.next; } return true; } //奇偶条件下 slow指针的位置 // 1-\u003e2-\u003e2-\u003e1-\u003enull // s s // f f // 1-\u003e2-\u003e1-\u003enull // s s // f f private Node findMid(Node head) { if(head == null || head.next) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:1:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"思路二: ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:2:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":" Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(1)$ 用快慢指针法找到链表的中点，然后将链表的后半段进行反转，然后cur1从头节点开始遍历，cur2从中点开始遍历，如果cur1指针所指向的值不等于cur2指针的值，那么就返回false，否则返回true，最好在返回时还能够将原链表复原 public Node ifPalindromeList(Node head) { if(head == null || head.next == null) { return true; } Node mid = findMid(head); Node head2 = reverseList(mid.next); //注意要断开 mid 和 mid.next 之间的联系 mid.next = null; Node cur2 = head2; Node cur1 = head; //就算是奇数个节点也没有问题 //因为奇数个节点的时候 其中cur2会走到null //而cur1会走到链表中点的位置 while (cur1 != null \u0026\u0026 cur2 != null) { if (cur1.val != cur2.val) { return false; } cur1 = cur1.next; cur2 = cur2.next; } head2 = reverseList(head2); mid.next = head2; return true; } private Node findMid(Node head) { if(head == null || head.next == null) { return head; } Node slow = head; Node fast = head; //注意这里是且的逻辑 否则会出现NPE while (fast.next != null \u0026\u0026 fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } private Node reverseList(Node head) { if (head == null || head.next == null) { return head; } Node pre = null; Node cur = head; Node nxt = head.next; // 1 -\u003e 2 -\u003e null // cur nxt while (nxt != null) { cur.next = pre; pre = cur; cur = nxt; nxt = nxt.next; } cur.next = pre; return cur; } ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:2:1","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":null,"content":"Rage, rage against the dying of the light! Old days shall fade away. 致力于研究美食，发掘自身潜能的一枚 AI beginner. 撰写博客只是为了开心，更多的是记录自己的学习过程 更多关于我的介绍请看简历/Resume ","date":"2021-11-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Development","Hugo"],"content":"GitHub设置 首先创建个人网站的一个repo： 注意命名规则:一定是你的用户名.github.io比如sophshep.github.io 详见下面这个图片: 建议：为了后续的开发也可以再创建一个仓库 Hugo安装及配置 首先安装 Hugo，在不同系统上安装都很简单，我使用的是 Mac ，使用 Homebrew 可以安装 Hugo： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"下载Hugo brew install hugo 创建一个基础网站 当你在当前路径下的终端内输入 hugo new site mySite 就会自动创建一个mySite的根文件夹┑(￣Д ￣)┍ ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"Hugo网站文件夹目录 顺带提一嘴这个文件结构，对后续写文章比较重要 mySite |–layout |–content |–static |–data |–themes |–config.toml |–archetypes content - 内容文件夹开发中的内容大多数都保存在这里 也就是markdown文件存储的位置 你post的文章的md后缀文件也会出现在这里 static - 静态文件夹一些静态的文件，比如说嵌入的图片,图片位置 themes - 主题文件夹 config.toml - 配置文件 基础的一些网站设置，比如网站的名字 archetypes - 样例文件夹 可以透过 hugo new \u003ccontentdir/contentfile.md\u003e来创建新的内容 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"选择并安装一个合适的主题并进行初始配置 挑选好一个theme之后load到你的本地 git submodule add \u003ctheme-github-url\u003e \u003ctarget-directory\u003e 下面我们要告诉Hugo我们所将使用的主题 echo 'theme = \"\u003ctheme-name\u003e\"' \u003e\u003e config.toml 我这里用的是： echo 'theme = \"even\"'\u003e\u003e config.toml 当然你也可以直接打开编辑器修改toml.config文件 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:1:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地测试一下你的新网站及博文 输入下面的命令后会自动发布一篇测试文章： hugo new post/testpage.md 新的testpage.md页面会存在content/post/testpage.md中，而content文件夹是Hugo创建静态网页的内容（你所写的博客基本都在这里） --- title: \"Testpage\" date: 2020-08-27T13:43:09-06:00 draft: true --- 打开archetypes/default.md可以发现，上面Testpage.md的内容是依赖下面的自动生成的，而draft的设置为true表明现在的Testpage处于草稿阶段，修改为false即可 --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true --- 需要注意的是： 第一个---到第二个--- 符号之间是front matter（Hugo的专用术语）类似于HTML中的\u003cmeta\u003e标签是用来定义页面头部的一些信息（渲染标题和其他的元数据）的，而在第二个--- 符号之后就是你的正文部分 或者说相当于HTML的body 关于config.toml的一些设置偏好 baseurl: 就是你想发布的网站：如https://.github.io title：标题，显示在每个页面的左上，一般都是自己的id languageCode：页面语言，指定编码格式，比如en-us/en-gb/cn表示英语-美国/英语-英国 paginate：在主页上显示多少条博客内容 [markup]:这一部部分显示使用哪一种markup/down语法，它一般不会渲染HTML标签否则可能产生安全问题，但如果你想要强制使用的话：设置unsafe = true [params] - 基础的参数设置 header_image - 默认的所有页面的背景图片，并且固定作为home页面和about页面的图片 title - 文章标题，显示在每个页面 slogan - 子标题 sidebar_about_description, sidebar_avatar, \u0026 about_me：侧边栏介绍，侧边栏可以用于简单的自我介绍，提供一些个人简介之类的，而将about_me设置为true就可以实现了 featured_tags： 是用来指定有多少个tags你想在页面中显示 feature_condition_size：指定每篇文章最少要给出多少个tag在tag云中 image_404 \u0026 title_404 - 当文章找不到，显示的404图片 omit_categories - 是否要忽略导航栏分类功能 [[params.additional_menus]] - 提供在导航栏中提供额外的菜单，比如About页面 [params.social] - 社交账户设置 baseurl = \"https://fakeRichardWH.github.io\" title = \"fakeRichardWH\" theme = \"even\" languageCode = \"en-us\" paginate = 5000 #frontpage pagination [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [params] header_image = \"images/main_go_wideandtall_darklayer.jpeg\" title = \"Software Engineering\" slogan = \"$ grep -rni \\\"The how's and why's\\\" .\" SEOTitle = \"fakeRichardWH Blog\" keyword = \"fakeRichardWH, TestTools, MachineLEARNING, JAVA, SpringBoot\" # Sidebar settings sidebar_about_description = \"Husband, Skier, Cyclist, and, oh yeah, Software Developer\" sidebar_avatar = \"images/MeAtUS.jpeg\" about_me = true featured_tags = true featured_condition_size = 2 # 当有多少条post时可以实现按标签索引 (大于) image_404 = \"images/404-bg.jpg\" title_404 = \"We couldn't find what you were looking for...\" omit_categories = false [[params.addtional_menus]] title = \"ABOUT\" href = \"/top/about/\" [params.social] rss = true email = \"testMe@gmail.com\" linkedin = \"https://www.linkedin.com/in/richard-youngkin-0749763\" github = \"https://github.com/youngkin\" stackoverflow = \"https://stackoverflow.com/users/2646870/rich\" reddit = \"https://www.reddit.com/user/elevation5280\" 常用命令（Hugo及Git） ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地服务器启动 下面这个代码会启动一个本地的Hugo Web服务器 hugo server -D 输入后会显示： Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 我们之后可以用浏览器打开该网址看看写的文章： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":" 一个完整的工作流 （写博文/更改博文） 1.创建一个文档hugo new post/my-xxx-post.md，用markdown语法 （推荐用VScode + Markdown的扩展，可以本地及时查看博文变动） 2.本地测试文档，删除一些不必要的文件 3.使用hugo命令 4.使用git命令完成相应文章的上传/更新 #写完博文之后 hugo cd public git add . git commit -m \"blog added\" git push -u origin master #一般都是在master分支上去操作 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"总结一下Hugo命令 hugo -D #搭建静态页面 输出到 ./public 目录中 如果不另外指定的话 hugo server # 一般是用于本地web服务器校对 hugo #部署时使用 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:3:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"content的目录结构 用下面一个样例结构来进行说明 content/ ├── about │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ │ ├── image1.jpg │ │ ├── image2.png │ │ └── index.md │ └── my-other-post │ └── index.md │ └── another-section ├── .. └── not-a-leaf-bundle ├── .. └── another-leaf-bundle └── index.md 上面这个是一个典型的四级目录包 about: 建立在root级别之下，其中只有一个index.md文件 my-post: image1: image2: my-other-post: ","date":"2021-11-03","objectID":"/post/hugocreatesite/:4:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"}]