[{"categories":["算法","java"],"content":" 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –\u003e y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。你的代码只接受原链表的头节点head作为传入参数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1: 生成clone节点copyNode，用HashMap来存储\u003c原始Node,拷贝Node\u003e这样的键值对，存储起来 再去设置copyNode的random和next指针。 利用这个键值对的性质，每个拷贝Node的random指针需要指向的位置：就是原始Node的random指针指向那个Node的拷贝，而要找到这个值，就是利用hashmap.get(Node.random) 比如：1 -\u003e 2,1' -\u003e 2' 由于(1，1‘)构成了键值对，(2，2’)也构成了键值对，所以1‘的random需要指向2的拷贝2’ 思路2: 对应每个原始链表的当前节点Cur生成Copy节点，将Copy节点放在原始链表的当前节点Cur的下一个位置nxt 再次遍历这个由新老节点构成的链表，设置Copy节点的random指针，它对应的random指向了Cur的random所指向的节点的下一个节点 最后我们只需要将原始链表从新构成的链表分离出来就可以了，返回的答案也要是新的拷贝链表的头节点 举个例子来说： 1 -\u003e 1' -\u003e 2 -\u003e 2' 原始链表中：2的random指向了1，那么在设置2‘的random时只需要将其指向1的next就可以了 两种思路的代码实现： // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } class Solution { HashMap\u003cNode, Node\u003e map = new HashMap\u003c\u003e(); /** ** 思路1 */ public Node copyRandomList1(Node head) { Node cur = head; //利用 key 存放原链表节点,val 存放copyNode while (cur != null) { Node copyCur = new Node(cur.val); map.put(cur,copyCur); cur = cur.next; } cur = head; //对应设置好 next 和 random指针 while (cur != null) { Node copyCur = map.get(cur); //能这样设置的原因，就是提前将 (cur, copyCur)放入， //而每个cur能映射到它对应的copyCur copyCur.next = map.get(cur.next); copyCur.random = map.get(cur.random); cur = cur.next; } return map.get(head); } //更省内存的方法 /** ** 思路2 */ public Node copyRandomList2(Node head) { if (head == null) { return null; } Node cur = head; Node nxt = null;//next指向原始链表中当前节点cur的下一个节点 Node copyCur = null; while (cur != null) { // 1 -\u003e 2 // cur nxt nxt = cur.next; // 1‘ 1 -\u003e 2 // copyCur cur nxt copyCur = new Node(cur.val); // 1 -\u003e 1‘ 2 // cur copyCur nxt cur.next = copyCur; // 1 -\u003e 1‘ -\u003e 2 // cur copyCur nxt copyCur.next = nxt; // 1 -\u003e 1' -\u003e 2 // cur cur = nxt; } //reset 回起点 cur = head; // 设置rand指针 while (cur != null) { // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur nxt copyCur = cur.next; nxt = cur.next.next; //一定要判断 cur.rand是否为null copyCur.random = cur.random != null ? cur.random.next : null; //移动copyCur和cur // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur cur = nxt; } //split 断开两个链表的连接 //先记下最终结果的头节点 Node res = head.next; cur = head; while (cur != null) { copyCur = cur.next; nxt = cur.next.next; // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur nxt // 1' -\u003e 2' // 1 -\u003e 2 copyCur.next = nxt != null ? nxt.next : null; cur.next = nxt; cur = nxt; } return res; } } ","date":"2021-11-24","objectID":"/post/copylistwithrand/:0:0","tags":["‘java’","‘LinkedList‘"],"title":"CopyListWithRand","uri":"/post/copylistwithrand/"},{"categories":["基础算法"],"content":"为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了 public static testStack() { Deque\u003cInteger\u003e stack = new Deque\u003cInteger\u003e(); stack.push(1); stack.push(3); stack.push(4); stack.peek(); // 4 stack.pop(); // 4 stack.pop(); // 3 stack.pop(); // 1 } Deque接口的stack主要调用有三个方法: push() peek() pop() 不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰 ","date":"2021-11-24","objectID":"/post/stack/:0:0","tags":["‘java’","‘算法’"],"title":"Stack","uri":"/post/stack/"},{"categories":null,"content":"Rage, rage against the dying of the light! Old days shall fade away. 致力于研究美食，发掘自身潜能的一枚 AI beginner. 撰写博客只是为了开心也是记录自己的学习过程 更多关于我的介绍请看简历/Resume ","date":"2021-11-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Development","Hugo"],"content":"GitHub设置 首先创建个人网站的一个repo： 注意命名规则:一定是你的用户名.github.io比如sophshep.github.io 详见下面这个图片: 建议：为了后续的开发也可以再创建一个仓库 Hugo安装及配置 首先安装 Hugo，在不同系统上安装都很简单，我使用的是 Mac ，使用 Homebrew 可以安装 Hugo： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:0","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"下载Hugo brew install hugo 创建一个基础网站 当你在当前路径下的终端内输入 hugo new site mySite 就会自动创建一个mySite的根文件夹┑(￣Д ￣)┍ ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:1","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"Hugo网站文件夹目录 顺带提一嘴这个文件结构，对后续写文章比较重要 mySite |–layout |–content |–static |–data |–themes |–config.toml |–archetypes content - 内容文件夹开发中的内容大多数都保存在这里 也就是markdown文件存储的位置 你post的文章的md后缀文件也会出现在这里 static - 静态文件夹一些静态的文件，比如说嵌入的图片,图片位置 themes - 主题文件夹 config.toml - 配置文件 基础的一些网站设置，比如网站的名字 archetypes - 样例文件夹 可以透过 hugo new \u003ccontentdir/contentfile.md\u003e来创建新的内容 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:2","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"选择并安装一个合适的主题并进行初始配置 挑选好一个theme之后load到你的本地 git submodule add \u003ctheme-github-url\u003e \u003ctarget-directory\u003e 下面我们要告诉Hugo我们所将使用的主题 echo 'theme = \"\u003ctheme-name\u003e\"' \u003e\u003e config.toml 我这里用的是： echo 'theme = \"even\"'\u003e\u003e config.toml 当然你也可以直接打开编辑器修改toml.config文件 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:1:0","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地测试一下你的新网站及博文 输入下面的命令后会自动发布一篇测试文章： hugo new post/testpage.md 新的testpage.md页面会存在content/post/testpage.md中，而content文件夹是Hugo创建静态网页的内容（你所写的博客基本都在这里） --- title: \"Testpage\" date: 2020-08-27T13:43:09-06:00 draft: true --- 打开archetypes/default.md可以发现，上面Testpage.md的内容是依赖下面的自动生成的，而draft的设置为true表明现在的Testpage处于草稿阶段，修改为false即可 --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true --- 需要注意的是： 第一个---到第二个--- 符号之间是front matter（Hugo的专用术语）类似于HTML中的\u003cmeta\u003e标签是用来定义页面头部的一些信息（渲染标题和其他的元数据）的，而在第二个--- 符号之后就是你的正文部分 或者说相当于HTML的body 关于config.toml的一些设置偏好 baseurl: 就是你想发布的网站：如https://.github.io title：标题，显示在每个页面的左上，一般都是自己的id languageCode：页面语言，指定编码格式，比如en-us/en-gb/cn表示英语-美国/英语-英国 paginate：在主页上显示多少条博客内容 [markup]:这一部部分显示使用哪一种markup/down语法，它一般不会渲染HTML标签否则可能产生安全问题，但如果你想要强制使用的话：设置unsafe = true [params] - 基础的参数设置 header_image - 默认的所有页面的背景图片，并且固定作为home页面和about页面的图片 title - 文章标题，显示在每个页面 slogan - 子标题 sidebar_about_description, sidebar_avatar, \u0026 about_me：侧边栏介绍，侧边栏可以用于简单的自我介绍，提供一些个人简介之类的，而将about_me设置为true就可以实现了 featured_tags： 是用来指定有多少个tags你想在页面中显示 feature_condition_size：指定每篇文章最少要给出多少个tag在tag云中 image_404 \u0026 title_404 - 当文章找不到，显示的404图片 omit_categories - 是否要忽略导航栏分类功能 [[params.additional_menus]] - 提供在导航栏中提供额外的菜单，比如About页面 [params.social] - 社交账户设置 baseurl = \"https://fakeRichardWH.github.io\" title = \"fakeRichardWH\" theme = \"even\" languageCode = \"en-us\" paginate = 5000 #frontpage pagination [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [params] header_image = \"images/main_go_wideandtall_darklayer.jpeg\" title = \"Software Engineering\" slogan = \"$ grep -rni \\\"The how's and why's\\\" .\" SEOTitle = \"fakeRichardWH Blog\" keyword = \"fakeRichardWH, TestTools, MachineLEARNING, JAVA, SpringBoot\" # Sidebar settings sidebar_about_description = \"Husband, Skier, Cyclist, and, oh yeah, Software Developer\" sidebar_avatar = \"images/MeAtUS.jpeg\" about_me = true featured_tags = true featured_condition_size = 2 # 当有多少条post时可以实现按标签索引 (大于) image_404 = \"images/404-bg.jpg\" title_404 = \"We couldn't find what you were looking for...\" omit_categories = false [[params.addtional_menus]] title = \"ABOUT\" href = \"/top/about/\" [params.social] rss = true email = \"testMe@gmail.com\" linkedin = \"https://www.linkedin.com/in/richard-youngkin-0749763\" github = \"https://github.com/youngkin\" stackoverflow = \"https://stackoverflow.com/users/2646870/rich\" reddit = \"https://www.reddit.com/user/elevation5280\" 常用命令（Hugo及Git） ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:0","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地服务器启动 下面这个代码会启动一个本地的Hugo Web服务器 hugo server -D 输入后会显示： Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 我们之后可以用浏览器打开该网址看看写的文章： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:1","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":" 一个完整的工作流 （写博文/更改博文） 1.创建一个文档hugo new post/my-xxx-post.md，用markdown语法 （推荐用VScode + Markdown的扩展，可以本地及时查看博文变动） 2.本地测试文档，删除一些不必要的文件 3.使用hugo命令 4.使用git命令完成相应文章的上传/更新 #写完博文之后 hugo cd public git add . git commit -m \"blog added\" git push -u origin master #一般都是在master分支上去操作 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:2","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"总结一下Hugo命令 hugo -D #搭建静态页面 输出到 ./public 目录中 如果不另外指定的话 hugo server # 一般是用于本地web服务器校对 hugo #部署时使用 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:3:0","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"content的目录结构 用下面一个样例结构来进行说明 content/ ├── about │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ │ ├── image1.jpg │ │ ├── image2.png │ │ └── index.md │ └── my-other-post │ └── index.md │ └── another-section ├── .. └── not-a-leaf-bundle ├── .. └── another-leaf-bundle └── index.md 上面这个是一个典型的四级目录包 about: 建立在root级别之下，其中只有一个index.md文件 my-post: image1: image2: my-other-post: ","date":"2021-11-03","objectID":"/post/hugocreatesite/:4:0","tags":["Hugo","GitHub","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"}]