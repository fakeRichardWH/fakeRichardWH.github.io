[{"categories":["Deep Learning"],"content":" 在图像复原的过程中，图像上一点点噪声就可能对复原的结果产生较大影响，由于复原算法本身一般都会放大噪声，这时候需要在最优化的问题模型中添加一个正则项约束图像的噪声 （其本身也是loss的一部分）比如图片中相邻像素值之间的差异，可通过降低TV loss来解决 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:0:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"Total Variation Loss (TV loss)初始定义： Rudin等人(Rudin 1990)观察到，受到噪声污染的图像总变分大于无噪声的图像总变分。那么就可以通过最小化图像总变分去抑制噪声，而图片中相邻像素值的差异可以通过降低TV loss来一定程度上缓解。比如对抗checkerboard。 总变分定义为梯度幅值大小的积分 $$ J(u) = \\int_{\\Omega_{u}}|\\nabla_{u}|{dxdy} = \\int_{D_{u}}\\sqrt{u_{x}^{2}+v_{x}^{2}}dxdy $$ 其中： $$ u_{x} = \\frac{\\partial{u}}{\\partial{x}},v_{y} = \\frac{\\partial{v}}{\\partial{y}}, $$ 而图像支持域为 $ D_{u} $ ,限制总变分就会限制噪声 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:1:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"扩展定义 带有阶数的TV loss如下 $$ J^{\\beta} (f)= \\int_{\\Omega}\\Big((\\frac{\\partial{f(u,v)}}{\\partial{u}})^{2}+(\\frac{\\partial{f(u,v)}}{\\partial{v}})^{2}\\Big)^{\\frac{\\beta}{2}}dxdy $$ 但是在图像中，连续的积分就是像素离散域求和 $$ J(x) = \\sum_{i,j}\\big( (x_{[i,j-1]}- x_{[i,j]})^{2}+(x_{[i+1,j]}- x_{[i,j]})^{2}\\big)^{\\frac{\\beta}{2}} $$ 也就是对于每个像素点$x_{[i,j]}$与其**正下方**的像素值差的平方加上其**正左方**的像素值差的平方，然后开$\\frac{\\beta}{2}$次根 ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:2:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":["Deep Learning"],"content":"3.基于pytorch实现及效果分析 import torch import torch.nn as nn from torch.autograd import Variable class TVLoss(nn.Module): def __init__(self,TVLoss_weight = 1):#设置TVLoss_weight为1 super(TVLoss, self).__init__() self.TVLoss_weight = TVLoss_weight def forward(self, x): #输入tensor为x # x = [batchSize,width,height,channels] batch_size = x.size()[0] h_x = x.size()[2] w_x = x.size()[3] #计算图片高度 count_h = self._tensor_size(x[:,:,1:,:]) #计算图片宽度 count_w = self._tensor_size(x[:,:,:,1:]) h_tv = torch.pow(x[:,:,1:,:]-x[:,:,:h_x-1,:]，2).sum() w_tv = torch.pow((x[:,:,:,1:]-x[:,:,:,:w_x-1]),2).sum() return self.TVLoss_weight*2*( h_tv/count_h + w_tv/count_w) / batch_size def _tensor_size(self, t): return t.size()[1]*t.size()[2]*t.size()[3] def main(): # x = Variable(torch.FloatTensor([[[1,2],[2,3]],[[1,2],[2,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[3,1],[4,3]],[[3,1],[4,3]]]).view(1,2,2,2), requires_grad=True) # x = Variable(torch.FloatTensor([[[1,1,1], [2,2,2],[3,3,3]],[[1,1,1], [2,2,2],[3,3,3]]]).view(1, 2, 3, 3), requires_grad=True) x = Variable(torch.FloatTensor([[[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [2, 3, 4], [3, 4, 5]]]).view(1, 2, 3, 3),requires_grad=True) addition = TVLoss() z = addition(x) print x print z.data z.backward() print x.grad if __name__ == '__main__': main() ","date":"2021-12-07","objectID":"/post/deeplearning-cnn-fundamentals1/:3:0","tags":["Deep Learning","TV loss"],"title":"深度学习-CNN相关01","uri":"/post/deeplearning-cnn-fundamentals1/"},{"categories":null,"content":"推荐系统的实验方法分类 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:0:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"1.离线实验 通过日志系统，获取用户行为数据，按照一定格式生产出一个标准的数据集 将数据集划分为训练集和测试集 在训练集上训练用户兴趣模型，并在测试集上进行预测 通过事先定义的离线指标评价算法在测试集上的预测结果 优点： 无需对实际系统有控制权（换言之，无需对真实有用户的系统来测试） 无需用户参与（仅仅根据用户历史数据） 速度快，可以测试大量算法 缺点： 无法真正计算商业上关注的指标：点击率，转化率（而且找到一个和商业指标相关的离线指标也很困难） 离线指标和实际商业指标有差距 （比如：预测准确率和用户的满意度之间就存在很大的差别） 总结 最好的办法就是将离线算法直接上线测试，但在对算法会不会降低用户满意度没有把握的情况下，上线测试有很高的风险，因此上线前一般需要进行一次用户调查 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:1:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"2.用户调查 1.调查真实用户，让他们在真实的推荐系统上完成一些任务 2.观察和记录用户行为，并且让用户回答一些相关的问题 3.通过分析用户调查的行为和答案，了解测试系统性能 优点： 体现更多用户的主观感受指标，相对在线实验风险很低，出错后容易弥补 可以展现出真实的客户需求，及满意度 缺点： 招募测试用户代价很高，很难组织大规模的测试用户，使得测试结果的统计意义不足 设计双盲实验十分困难，用户在实验环境下的行为和真实场景会呈现出不同 总结： 需要选取与真实用户身份分布一致的测试用户数量，比如年龄/活跃度，此外需要保证用户的回答可靠，不要让实验者和用户提前知道测试的目的，以免回答受到影响 ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:2:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":null,"content":"3.在线实验 将推荐系统上线做AB测试，将它和旧的算法进行比较 优点： 缺点： 总结： ","date":"2021-12-02","objectID":"/post/recommendationsystem01/:3:0","tags":null,"title":"RecommendationSystem 01","uri":"/post/recommendationsystem01/"},{"categories":["leetcode","java"],"content":" 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –\u003e y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。你的代码只接受原链表的头节点head作为传入参数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1: 生成clone节点copyNode，用HashMap来存储\u003c原始Node,拷贝Node\u003e这样的键值对，存储起来 再去设置copyNode的random和next指针。 利用这个键值对的性质，每个拷贝Node的random指针需要指向的位置：就是原始Node的random指针指向那个Node的拷贝，而要找到这个值，就是利用hashmap.get(Node.random) 比如：1 -\u003e 2,1' -\u003e 2' 由于(1，1‘)构成了键值对，(2，2’)也构成了键值对，所以1‘的random需要指向2的拷贝2’ 思路2: 对应每个原始链表的当前节点Cur生成Copy节点，将Copy节点放在原始链表的当前节点Cur的下一个位置nxt 再次遍历这个由新老节点构成的链表，设置Copy节点的random指针，它对应的random指向了Cur的random所指向的节点的下一个节点 最后我们只需要将原始链表从新构成的链表分离出来就可以了，返回的答案也要是新的拷贝链表的头节点 举个例子来说一个新构成的链表如下： 1 -\u003e 1' -\u003e 2 -\u003e 2' 假定原始链表中：2的random指向了1，那么在设置2‘的random时只需要将其指向1的next就可以了 两种思路的代码实现： // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } class Solution { HashMap\u003cNode, Node\u003e map = new HashMap\u003c\u003e(); /** ** 思路1 */ public Node copyRandomList1(Node head) { Node cur = head; //利用 key 存放原链表节点,val 存放copyNode while (cur != null) { Node copyCur = new Node(cur.val); map.put(cur,copyCur); cur = cur.next; } cur = head; //对应设置好 next 和 random指针 while (cur != null) { Node copyCur = map.get(cur); //能这样设置的原因，就是提前将 (cur, copyCur)放入， //而每个cur能映射到它对应的copyCur copyCur.next = map.get(cur.next); copyCur.random = map.get(cur.random); cur = cur.next; } return map.get(head); } //更省内存的方法 /** ** 思路2 */ public Node copyRandomList2(Node head) { if (head == null) { return null; } Node cur = head; Node nxt = null;//next指向原始链表中当前节点cur的下一个节点 Node copyCur = null; while (cur != null) { // 1 -\u003e 2 // cur nxt nxt = cur.next; // 1‘ 1 -\u003e 2 // copyCur cur nxt copyCur = new Node(cur.val); // 1 -\u003e 1‘ 2 // cur copyCur nxt cur.next = copyCur; // 1 -\u003e 1‘ -\u003e 2 // cur copyCur nxt copyCur.next = nxt; // 1 -\u003e 1' -\u003e 2 // cur cur = nxt; } //reset 回起点 cur = head; // 设置rand指针 while (cur != null) { // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur nxt copyCur = cur.next; nxt = cur.next.next; //一定要判断 cur.rand是否为null copyCur.random = cur.random != null ? cur.random.next : null; //移动copyCur和cur // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur cur = nxt; } //split 断开两个链表的连接 //先记下最终结果的头节点 Node res = head.next; cur = head; while (cur != null) { copyCur = cur.next; nxt = cur.next.next; // 1 -\u003e 1' -\u003e 2 -\u003e 2' // cur copyCur nxt // 1' -\u003e 2' // 1 -\u003e 2 copyCur.next = nxt != null ? nxt.next : null; cur.next = nxt; cur = nxt; } return res; } } ","date":"2021-11-24","objectID":"/post/copylistwithrand/:0:0","tags":["LinkedList"],"title":"leetcode-Copy Linkedlist with Random pointer","uri":"/post/copylistwithrand/"},{"categories":["java基础"],"content":"为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了 public static testStack() { Deque\u003cInteger\u003e stack = new Deque\u003cInteger\u003e(); stack.push(1); stack.push(3); stack.push(4); stack.peek(); // 4 stack.pop(); // 4 stack.pop(); // 3 stack.pop(); // 1 } Deque接口的stack主要调用有三个方法: push() peek() pop() 不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰 ","date":"2021-11-24","objectID":"/post/stack/:0:0","tags":["Java"],"title":"java-Stack","uri":"/post/stack/"},{"categories":["leetcode","java"],"content":"Q1: 判断一个链表 是否属于回文结构 // example1 input: 1 -\u003e 2 -\u003e 23 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example2 input: 1 -\u003e 2 -\u003e 23 -\u003e 2 -\u003e 1 output: true // example3 input: 1 -\u003e 2 -\u003e 23 -\u003e 3 -\u003e 1 output: false ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:0:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":["leetcode","java"],"content":"思路一: 利用一个stack来实现 Time Complexity: $\\mathcal{O}(n)$ Space Complexity: $\\mathcal{O}(n)$ ","date":"2021-11-24","objectID":"/post/palindromelinkedlist/:1:0","tags":["LinkedList"],"title":"leetcode-判断一个链表是否为回文结构","uri":"/post/palindromelinkedlist/"},{"categories":null,"content":"Rage, rage against the dying of the light! Old days shall fade away. 致力于研究美食，发掘自身潜能的一枚 AI beginner. 撰写博客只是为了开心，更多的是记录自己的学习过程 更多关于我的介绍请看简历/Resume ","date":"2021-11-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Development","Hugo"],"content":"GitHub设置 首先创建个人网站的一个repo： 注意命名规则:一定是你的用户名.github.io比如sophshep.github.io 详见下面这个图片: 建议：为了后续的开发也可以再创建一个仓库 Hugo安装及配置 首先安装 Hugo，在不同系统上安装都很简单，我使用的是 Mac ，使用 Homebrew 可以安装 Hugo： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"下载Hugo brew install hugo 创建一个基础网站 当你在当前路径下的终端内输入 hugo new site mySite 就会自动创建一个mySite的根文件夹┑(￣Д ￣)┍ ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"Hugo网站文件夹目录 顺带提一嘴这个文件结构，对后续写文章比较重要 mySite |–layout |–content |–static |–data |–themes |–config.toml |–archetypes content - 内容文件夹开发中的内容大多数都保存在这里 也就是markdown文件存储的位置 你post的文章的md后缀文件也会出现在这里 static - 静态文件夹一些静态的文件，比如说嵌入的图片,图片位置 themes - 主题文件夹 config.toml - 配置文件 基础的一些网站设置，比如网站的名字 archetypes - 样例文件夹 可以透过 hugo new \u003ccontentdir/contentfile.md\u003e来创建新的内容 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:0:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"选择并安装一个合适的主题并进行初始配置 挑选好一个theme之后load到你的本地 git submodule add \u003ctheme-github-url\u003e \u003ctarget-directory\u003e 下面我们要告诉Hugo我们所将使用的主题 echo 'theme = \"\u003ctheme-name\u003e\"' \u003e\u003e config.toml 我这里用的是： echo 'theme = \"even\"'\u003e\u003e config.toml 当然你也可以直接打开编辑器修改toml.config文件 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:1:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地测试一下你的新网站及博文 输入下面的命令后会自动发布一篇测试文章： hugo new post/testpage.md 新的testpage.md页面会存在content/post/testpage.md中，而content文件夹是Hugo创建静态网页的内容（你所写的博客基本都在这里） --- title: \"Testpage\" date: 2020-08-27T13:43:09-06:00 draft: true --- 打开archetypes/default.md可以发现，上面Testpage.md的内容是依赖下面的自动生成的，而draft的设置为true表明现在的Testpage处于草稿阶段，修改为false即可 --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true --- 需要注意的是： 第一个---到第二个--- 符号之间是front matter（Hugo的专用术语）类似于HTML中的\u003cmeta\u003e标签是用来定义页面头部的一些信息（渲染标题和其他的元数据）的，而在第二个--- 符号之后就是你的正文部分 或者说相当于HTML的body 关于config.toml的一些设置偏好 baseurl: 就是你想发布的网站：如https://.github.io title：标题，显示在每个页面的左上，一般都是自己的id languageCode：页面语言，指定编码格式，比如en-us/en-gb/cn表示英语-美国/英语-英国 paginate：在主页上显示多少条博客内容 [markup]:这一部部分显示使用哪一种markup/down语法，它一般不会渲染HTML标签否则可能产生安全问题，但如果你想要强制使用的话：设置unsafe = true [params] - 基础的参数设置 header_image - 默认的所有页面的背景图片，并且固定作为home页面和about页面的图片 title - 文章标题，显示在每个页面 slogan - 子标题 sidebar_about_description, sidebar_avatar, \u0026 about_me：侧边栏介绍，侧边栏可以用于简单的自我介绍，提供一些个人简介之类的，而将about_me设置为true就可以实现了 featured_tags： 是用来指定有多少个tags你想在页面中显示 feature_condition_size：指定每篇文章最少要给出多少个tag在tag云中 image_404 \u0026 title_404 - 当文章找不到，显示的404图片 omit_categories - 是否要忽略导航栏分类功能 [[params.additional_menus]] - 提供在导航栏中提供额外的菜单，比如About页面 [params.social] - 社交账户设置 baseurl = \"https://fakeRichardWH.github.io\" title = \"fakeRichardWH\" theme = \"even\" languageCode = \"en-us\" paginate = 5000 #frontpage pagination [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [params] header_image = \"images/main_go_wideandtall_darklayer.jpeg\" title = \"Software Engineering\" slogan = \"$ grep -rni \\\"The how's and why's\\\" .\" SEOTitle = \"fakeRichardWH Blog\" keyword = \"fakeRichardWH, TestTools, MachineLEARNING, JAVA, SpringBoot\" # Sidebar settings sidebar_about_description = \"Husband, Skier, Cyclist, and, oh yeah, Software Developer\" sidebar_avatar = \"images/MeAtUS.jpeg\" about_me = true featured_tags = true featured_condition_size = 2 # 当有多少条post时可以实现按标签索引 (大于) image_404 = \"images/404-bg.jpg\" title_404 = \"We couldn't find what you were looking for...\" omit_categories = false [[params.addtional_menus]] title = \"ABOUT\" href = \"/top/about/\" [params.social] rss = true email = \"testMe@gmail.com\" linkedin = \"https://www.linkedin.com/in/richard-youngkin-0749763\" github = \"https://github.com/youngkin\" stackoverflow = \"https://stackoverflow.com/users/2646870/rich\" reddit = \"https://www.reddit.com/user/elevation5280\" 常用命令（Hugo及Git） ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"本地服务器启动 下面这个代码会启动一个本地的Hugo Web服务器 hugo server -D 输入后会显示： Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 我们之后可以用浏览器打开该网址看看写的文章： ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:1","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":" 一个完整的工作流 （写博文/更改博文） 1.创建一个文档hugo new post/my-xxx-post.md，用markdown语法 （推荐用VScode + Markdown的扩展，可以本地及时查看博文变动） 2.本地测试文档，删除一些不必要的文件 3.使用hugo命令 4.使用git命令完成相应文章的上传/更新 #写完博文之后 hugo cd public git add . git commit -m \"blog added\" git push -u origin master #一般都是在master分支上去操作 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:2:2","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"总结一下Hugo命令 hugo -D #搭建静态页面 输出到 ./public 目录中 如果不另外指定的话 hugo server # 一般是用于本地web服务器校对 hugo #部署时使用 ","date":"2021-11-03","objectID":"/post/hugocreatesite/:3:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"},{"categories":["Development","Hugo"],"content":"content的目录结构 用下面一个样例结构来进行说明 content/ ├── about │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ │ ├── image1.jpg │ │ ├── image2.png │ │ └── index.md │ └── my-other-post │ └── index.md │ └── another-section ├── .. └── not-a-leaf-bundle ├── .. └── another-leaf-bundle └── index.md 上面这个是一个典型的四级目录包 about: 建立在root级别之下，其中只有一个index.md文件 my-post: image1: image2: my-other-post: ","date":"2021-11-03","objectID":"/post/hugocreatesite/:4:0","tags":["Hugo","Github","toml"],"title":"利用Hugo和GitHub Pages搭建个人博客网站","uri":"/post/hugocreatesite/"}]